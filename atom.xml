<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leetao&#39;s Blog</title>
  
  <subtitle>Talk is cheap, show me the code</subtitle>
  <link href="https://leetaogoooo.github.io/atom.xml" rel="self"/>
  
  <link href="https://leetaogoooo.github.io/"/>
  <updated>2022-04-12T07:10:22.037Z</updated>
  <id>https://leetaogoooo.github.io/</id>
  
  <author>
    <name>Leetao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 列表内存预分配问题</title>
    <link href="https://leetaogoooo.github.io/2022/04/12/Python%20%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://leetaogoooo.github.io/2022/04/12/Python%20%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下例子均的运行环境为 Python 3.9.5，不同版本的实际运行结果可能有所不同</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前端时间看了 Golang 的 学习了一下 数组 和 Slice，其中 Slice 相当于动态数组，其中数组的长度是固定的，而 Slice 则是不定长的。在 Python 中是没有数组和 Slice 的概念，它们可以通通归类为 List（列表），那么问题来了，定长的 List 和 不定长的 List 在表现上会有区别吗？（这里的定长的 List 是指对 List 进行初始化,也就是所谓的预分配）<br>接下来通过几个例子去验证这个问题。</p><span id="more"></span><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>首先验证一下 空列表 以及在不断新增元素的情况下 List 的 size 的变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getsizeof</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;空列表:<span class="subst">&#123;getsizeof(l)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    l.append(l)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;存在<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>元素的列表:<span class="subst">&#123;getsizeof(l)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>看一下输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">空列表:56</span><br><span class="line">存在1元素的列表:88</span><br><span class="line">存在2元素的列表:88</span><br><span class="line">存在3元素的列表:88</span><br><span class="line">存在4元素的列表:88</span><br><span class="line">存在5元素的列表:120</span><br><span class="line">存在6元素的列表:120</span><br><span class="line">存在7元素的列表:120</span><br><span class="line">存在8元素的列表:120</span><br><span class="line">存在9元素的列表:184</span><br><span class="line">存在10元素的列表:184</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/image_1649729308457_0.png"></p><p>从上面的运行结果可以发现，其实 List 也存在一定的扩容机制的，列表初始化过程中将会申请一个存储四个元素的存储区，当存储区填满时，列表会再次申请四个存储空间存储元素。当元素量达到原存储空间的两倍时，列表会再次申请原来旧的存储空间的两倍的容量存储元素。</p><p>不管任何语言在一旦进行扩容操作必然会存在：<br>      1. 重新申请内存<br>        2. 复制老数组到新的内存<br>        3. 回收老数组的内存</p><p>上面的过程如果出现的次数比较频繁必然会导致运行速度的降低，那么究竟会降低多少呢？</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以下例子运行环境为 ipython</p><h3 id="没有任何处理的例子"><a href="#没有任何处理的例子" class="headerlink" title="没有任何处理的例子"></a>没有任何处理的例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">l=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    l.append(i)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%88%AA%E5%B1%8F2022-04-12_%E4%B8%8B%E5%8D%882.42.23_1649745745624_0.png"></p><h3 id="预分配后的列表"><a href="#预分配后的列表" class="headerlink" title="预分配后的列表"></a>预分配后的列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%timeit</span><br><span class="line">size = <span class="number">1000</span></span><br><span class="line">l = [<span class="literal">None</span>] * size</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">    l[i] = i</span><br></pre></td></tr></table></figure><p>和上面唯一不同的是，我们在遍历之前，给列表 l 预先分配了一个长度为 1000 的 None 的空数组，运行结果如下：</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%88%AA%E5%B1%8F2022-04-12_%E4%B8%8B%E5%8D%882.45.50_1649745952420_0.png"></p><p>从这两个例子不难看出，如果预先知道要使用数组的大小，并且对列表进行初始化的话，是可以在一定程度上提高运行效率的。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>上面的例子，如果使用列表推导式速度会更快。</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%88%AA%E5%B1%8F2022-04-12_%E4%B8%8B%E5%8D%882.50.30_1649746232891_0.png"></p><p>列表预先配可能并不适合复杂场景，但是一旦有符合这个特殊场景的情况下效果应该是蛮不错的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以下例子均的运行环境为 Python 3.9.5，不同版本的实际运行结果可能有所不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前端时间看了 Golang 的 学习了一下 数组 和 Slice，其中 Slice 相当于动态数组，其中数组的长度是固定的，而 Slice 则是不定长的。在 Python 中是没有数组和 Slice 的概念，它们可以通通归类为 List（列表），那么问题来了，定长的 List 和 不定长的 List 在表现上会有区别吗？（这里的定长的 List 是指对 List 进行初始化,也就是所谓的预分配）&lt;br&gt;接下来通过几个例子去验证这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="优化" scheme="https://leetaogoooo.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Python" scheme="https://leetaogoooo.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python解析JSON大文件</title>
    <link href="https://leetaogoooo.github.io/2022/03/30/Python%E8%A7%A3%E6%9E%90JSON%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    <id>https://leetaogoooo.github.io/2022/03/30/Python%E8%A7%A3%E6%9E%90JSON%E5%A4%A7%E6%96%87%E4%BB%B6/</id>
    <published>2022-03-29T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际开发中，有时候需要用 Python 去处理一些 JSON 文件，一旦 JSON 文件过大，就有可能出现加载时间过长，内存消耗过大的问题，甚至会导致内存耗尽。所以如果正确地处理大的 JSON 文件呢？</p><span id="more"></span><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>首先构造一个大的 JSON 文件，这里我们使用一个在 github上开源的一个 json 文件 <a href="https://github.com/json-iterator/test-data/blob/master/large-file.json">large-file.json</a>，文件大小为 24.9 M</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%88%AA%E5%B1%8F2022-03-30_14.30.06_1648621812730_0.png"></p><p>文件内容大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;2489651045&quot;</span>,<span class="attr">&quot;type&quot;</span>:<span class="string">&quot;CreateEvent&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;actor&quot;</span>:&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">665991</span>,<span class="attr">&quot;login&quot;</span>:<span class="string">&quot;petroav&quot;</span>,<span class="attr">&quot;gravatar_id&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="attr">&quot;url&quot;</span>:<span class="string">&quot;https://api.github.com/users/petroav&quot;</span>,<span class="attr">&quot;avatar_url&quot;</span>:<span class="string">&quot;https://avatars.githubusercontent.com/u/665991?&quot;</span>&#125;,</span><br><span class="line">   <span class="attr">&quot;repo&quot;</span>:&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">28688495</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;petroav/6.828&quot;</span>,<span class="attr">&quot;url&quot;</span>:<span class="string">&quot;https://api.github.com/repos/petroav/6.828&quot;</span>&#125;,</span><br><span class="line">   <span class="attr">&quot;payload&quot;</span>:&#123;<span class="attr">&quot;ref&quot;</span>:<span class="string">&quot;master&quot;</span>,<span class="attr">&quot;ref_type&quot;</span>:<span class="string">&quot;branch&quot;</span>,<span class="attr">&quot;master_branch&quot;</span>:<span class="string">&quot;master&quot;</span>,<span class="attr">&quot;description&quot;</span>:<span class="string">&quot;Solution to homework and assignments from MIT&#x27;s 6.828 (Operating Systems Engineering). Done in my spare time.&quot;</span>,<span class="attr">&quot;pusher_type&quot;</span>:<span class="string">&quot;user&quot;</span>&#125;,</span><br><span class="line">   <span class="attr">&quot;public&quot;</span>:<span class="literal">true</span>,<span class="attr">&quot;created_at&quot;</span>:<span class="string">&quot;2015-01-01T15:00:00Z&quot;</span>&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接下来我们将会通过不同的方案去解析这个json文件，然后提取对应的 actor.id 和 repo.id 的内容，借助 fileprofiler 去验证不同方案中内存的消耗情况。</p><h2 id="使用内置标准库-json"><a href="#使用内置标准库-json" class="headerlink" title="使用内置标准库-json"></a>使用内置标准库-json</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;large-file.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br><span class="line"></span><br><span class="line">user_to_repos = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> data:</span><br><span class="line">    user = record[<span class="string">&quot;actor&quot;</span>][<span class="string">&quot;login&quot;</span>]</span><br><span class="line">    repo = record[<span class="string">&quot;repo&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> user_to_repos:</span><br><span class="line">        user_to_repos[user] = <span class="built_in">set</span>()</span><br><span class="line">    user_to_repos[user].add(repo)</span><br></pre></td></tr></table></figure><p>通过 fileprofiler 看一下运行结果：</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%88%AA%E5%B1%8F2022-03-30_%E4%B8%8B%E5%8D%885.08.57_1648631340541_0.png"></p><p>从上面的图，不难看出，内存重灾区为两处：<br>    1. 读取文件<br>    2. 结果进行 decode</p><p>看一下 <code>json</code> 模块的<a href="https://github.com/python/cpython/blob/15da2a2723245710f1bd2c7cbd5b450532ae7728/Lib/json/__init__.py#L293">实现源码</a>，不难发现，在解析之前，<code>json.load()</code> 将整个文件都加载到内存当中去了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span>(<span class="params">fp, *, cls=<span class="literal">None</span>, object_hook=<span class="literal">None</span>, parse_float=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        parse_int=<span class="literal">None</span>, parse_constant=<span class="literal">None</span>, object_pairs_hook=<span class="literal">None</span>, **kw</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Deserialize ``fp`` (a ``.read()``-supporting file-like object containing</span></span><br><span class="line"><span class="string">    a JSON document) to a Python object.</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> loads(fp.read(),...)</span><br></pre></td></tr></table></figure><p>所以显然易见，如果直接加载文件将会占用大量内存。这里还有一个值得思考的问题，为什么文件大小只有 24.9 M，而使用的内存竟然高达 124 M 呢？这个主要是和 Python 字符串的内存表示 有关，简单看一下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&quot;a&quot;</span> * <span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(s)</span><br><span class="line"><span class="number">1049</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">&quot;❄&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s2)</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(s2)</span><br><span class="line"><span class="number">2074</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = <span class="string">&quot;🚩&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s3)</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getsizeof(s3)</span><br><span class="line"><span class="number">4076</span></span><br></pre></td></tr></table></figure><p>三个字符串的长度都是 1000，但是它们占用的内存却是各不相同，所以 JSON 文件占用内存的大小并不是取决于它们包含的字符串的长度，而是字符串里包含什么类似的字符。<br>回归正题，显然使用内置的标准库 <code>json</code> 的效果并不是很理想，所以有没有更好的方案呢？对于大的 JSON 文件并不是一次性加载到内存当中去，而是按需加载，这种方式也有一个名称叫做 - 流（stream）<br>有很多三方库支持这个特性，接下来我们尝试使用其中一个库 <a href="https://github.com/ICRAR/ijson">ijson</a></p><h1 id="三方库-ijson"><a href="#三方库-ijson" class="headerlink" title="三方库 - ijson"></a>三方库 - ijson</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ijson</span><br><span class="line"></span><br><span class="line">user_to_repos = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;large-file.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> ijson.items(f, <span class="string">&quot;item&quot;</span>):</span><br><span class="line">        user = record[<span class="string">&quot;actor&quot;</span>][<span class="string">&quot;login&quot;</span>]</span><br><span class="line">        repo = record[<span class="string">&quot;repo&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> user_to_repos:</span><br><span class="line">            user_to_repos[user] = <span class="built_in">set</span>()</span><br><span class="line">        user_to_repos[user].add(repo)</span><br></pre></td></tr></table></figure><p>同样使用 fileprofiler 看一下运行结果</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%88%AA%E5%B1%8F2022-03-30_%E4%B8%8B%E5%8D%886.21.59_1648635722250_0.png"></p><p>从图片不难看出来，内存消耗一下子就降低了下来。所以下次有大的 JSON 文件，可以尝试用 <code>ijson</code> 库</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p> <a href="https://github.com/ICRAR/ijson">ijson</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在实际开发中，有时候需要用 Python 去处理一些 JSON 文件，一旦 JSON 文件过大，就有可能出现加载时间过长，内存消耗过大的问题，甚至会导致内存耗尽。所以如果正确地处理大的 JSON 文件呢？&lt;/p&gt;</summary>
    
    
    
    <category term="优化" scheme="https://leetaogoooo.github.io/categories/%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Python" scheme="https://leetaogoooo.github.io/tags/Python/"/>
    
    <category term="JSON" scheme="https://leetaogoooo.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>python 中实现类方法重载</title>
    <link href="https://leetaogoooo.github.io/2022/02/14/python%20%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    <id>https://leetaogoooo.github.io/2022/02/14/python%20%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</id>
    <published>2022-02-13T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Java 中有 [[重载]] 的概念：</p><blockquote><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p></blockquote><p>Python 本身不支持 <code>重载</code> 这个特性，但是通过 <code>functools.singledispatch</code>  可以实现函数的重载。接下来通过一个例子，简单地演示一下 Python 的函数重载。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">arg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun.register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">arg: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;arg is int: <span class="subst">&#123;arg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@fun.register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">arg: <span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;arg is list: <span class="subst">&#123;arg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@fun.register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">arg: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;arg is str: <span class="subst">&#123;arg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fun([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">    fun(<span class="number">1</span>)</span><br><span class="line">    fun(<span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行程序查看一下结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arg is list: [1, 2, 3]</span><br><span class="line">arg is int: 1</span><br><span class="line">arg is str: str</span><br></pre></td></tr></table></figure><p>根据参数的不同的类型，成功了执行了对应的函数，到这里我们完成了 Python 中对函数的<code>重载</code>。Java 中 <code>重载</code> 不仅仅针对普通函数，其类方法也支持这个特性，那么 Python 如何实现类方法的<code>重载</code>呢？</p><h1 id="类方法重载"><a href="#类方法重载" class="headerlink" title="类方法重载"></a>类方法重载</h1><h2 id="Python-gt-3-8"><a href="#Python-gt-3-8" class="headerlink" title="Python &gt;= 3.8"></a>Python &gt;= 3.8</h2><p>当 Python 版本不低于 3.8 的时候，<code>functools</code> 新增了一个 <code>singledispatchmethod</code> 方法，这个方法可以让 Python 的类方法支持 <code>重载</code>，使用方法和 <code>singledispatch</code> 类似，唯一需要注意的是，重载的类型是由类函数中第一个非 <code>self</code> 和 <code>cls</code> 的参数类型决定的。</p><p>看一下官方实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @singledispatchmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Cannot negate a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">self, arg: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">self, arg: <span class="built_in">bool</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br></pre></td></tr></table></figure><p>除此之外，<code>singledispatchmethod</code> 还支持嵌套的装饰器，不过需要注意的是，<code>dispatcher.register</code> 和 <code>singledispatchmethod</code> 需要在绝大多数装饰器的最上层，基于上面的例子修改一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @singledispatchmethod</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span>(<span class="params">cls, arg</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Cannot negate a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">cls, arg: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">cls, arg: <span class="built_in">bool</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br></pre></td></tr></table></figure><h2 id="Python-lt-3-8"><a href="#Python-lt-3-8" class="headerlink" title="Python &lt; 3.8"></a>Python &lt; 3.8</h2><p>当 Python 版本小于 3.8 的时候，由于 Python 本身不支持类方法的<code>重载</code>，则需要我们自行实现。在实现之前，可以先借鉴一下 [<code>singledispatch</code> 的源码](<a href="https://hg.python.org/cpython/file/f6f691ff27b9/Lib/functools.py#l706">cpython: f6f691ff27b9 Lib/functools.py</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(args[<span class="number">0</span>].__class__)(*args, **kw)</span><br></pre></td></tr></table></figure><p>从源码中不难看得出 <code>singledispatch</code> 最终返回的就是上述的 <code>wrapper</code> 函数，并且函数是根据函数的第一个参数的类型（<code>args[0].__class__</code>）最终来实现函数的<code>重载</code>的，对于函数这种实现方式没有任何问题，但是如果是类方法的话，第一个参数始终是 <code>self</code>，则无法进行区分了，<code>重载</code>就更无从谈起了。</p><p>所以实现类方法的重载难点在于重写 <code>wrapper</code> 函数，所以在 <code>singledispatch</code> 基础上我们定义一个函数对<code>wrapper</code> 进行重写，把 wrapper 中的参数 <code>args[0]</code> 调整为 <code>args[1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch, update_wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">methdispatch</span>(<span class="params">func</span>):</span></span><br><span class="line">    dispatcher = singledispatch(func)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">return</span> dispatcher.dispatch(args[<span class="number">1</span>].__class__)(*args, **kw)</span><br><span class="line">    wrapper.register = dispatcher.register</span><br><span class="line">    update_wrapper(wrapper, func)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>接下来测试一下这个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @methdispatch</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Cannot negate a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">self, arg: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span>(<span class="params">self, arg: <span class="built_in">bool</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    neg = Negator()</span><br><span class="line">    neg.neg(<span class="number">1</span>)</span><br><span class="line">    neg.neg(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>到此手动实现类方法的重载成功。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在 pypi 上也有对应的 <a href="https://pypi.org/project/singledispatchmethod/">singledispatchmethod · PyPI</a> 库，可以通过 pip 安装后直接使用，用法和 3.8 之后版本用法一致。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://stackoverflow.com/questions/24601722/how-can-i-use-functools-singledispatch-with-instance-methods?utm_source=pocket_mylist">python - How can I use functools.singledispatch with instance methods? - Stack Overflow</a></li><li><a href="https://hg.python.org/cpython/file/f6f691ff27b9/Lib/functools.py#l706">cpython: f6f691ff27b9 Lib/functools.py</a></li><li><a href="https://legacy.python.org/dev/peps/pep-3124/">PEP 3124 – Overloading, Generic Functions, Interfaces, and Adaptation (python.org)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Java 中有 [[重载]] 的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python 本身不支持 &lt;code&gt;重载&lt;/code&gt; 这个特性，但是通过 &lt;code&gt;functools.singledispatch&lt;/code&gt;  可以实现函数的重载。接下来通过一个例子，简单地演示一下 Python 的函数重载。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://leetaogoooo.github.io/tags/python/"/>
    
    <category term="singledispatch" scheme="https://leetaogoooo.github.io/tags/singledispatch/"/>
    
  </entry>
  
  <entry>
    <title>django bulk_create support post_save signal</title>
    <link href="https://leetaogoooo.github.io/2022/02/05/django-bulk-create-support-post-save-signal/"/>
    <id>https://leetaogoooo.github.io/2022/02/05/django-bulk-create-support-post-save-signal/</id>
    <published>2022-02-04T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>django 默认 <code>bulk_create</code> 不支持 <code>signal</code>，可以通过自定义 <code>models.Manager</code> 支持这个特性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomManager</span>(<span class="params">models.Manager</span>):</span>  </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">bulk_create</span>(<span class="params">self, items, **kwargs</span>):</span>  </span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> items:  </span><br><span class="line"> post_save.send(i.__class__, instance=i, created=<span class="literal">True</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().bulk_create(items, **kwargs)  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bulk_update</span>(<span class="params">self, items, fields, **kwargs</span>):</span>  </span><br><span class="line"> <span class="built_in">super</span>().bulk_update(items, fields, **kwargs)  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> items:  </span><br><span class="line"> post_save.send(i.__class__, instance=i, created=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>使用实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params">db.models</span>):</span></span><br><span class="line">objects = CustomManager()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;django 默认 &lt;code&gt;bulk_create&lt;/code&gt; 不支持 &lt;code&gt;signal&lt;/code&gt;，可以通过自定义 &lt;code&gt;models.Manager&lt;/code&gt; 支持这个特性&lt;/p&gt;
&lt;figure class=&quot;highlight python</summary>
      
    
    
    
    
    <category term="django" scheme="https://leetaogoooo.github.io/tags/django/"/>
    
    <category term="orm" scheme="https://leetaogoooo.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>django orm custom mysql round function</title>
    <link href="https://leetaogoooo.github.io/2022/01/30/django-orm-custom-mysql-round-function/"/>
    <id>https://leetaogoooo.github.io/2022/01/30/django-orm-custom-mysql-round-function/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.048Z</updated>
    
    <content type="html"><![CDATA[<p><code>Django.db.models</code> 自带的 <code>Round</code> 的函数没有不支持小数点位数的保留，默认保留2位，通过自定义的 <code>Func</code> 可以实现调用 <code>MySQL</code> 的 <code>ROUND</code> 函数</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundPlus</span>(<span class="params">Func</span>):</span>  </span><br><span class="line"> function = <span class="string">&#x27;ROUND&#x27;</span>  </span><br><span class="line"> template = <span class="string">&#x27;%(function)s(%(expressions)s, %(precision)s)&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *expressions, precision=<span class="number">2</span></span>):</span>  </span><br><span class="line"> <span class="built_in">super</span>().__init__(*expressions, precision=precision)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Django.db.models&lt;/code&gt; 自带的 &lt;code&gt;Round&lt;/code&gt; 的函数没有不支持小数点位数的保留，默认保留2位，通过自定义的 &lt;code&gt;Func&lt;/code&gt; 可以实现调用 &lt;code&gt;MySQL&lt;/code&gt; 的 &lt;code&gt;ROUND&lt;/code&gt; 函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="django" scheme="https://leetaogoooo.github.io/tags/django/"/>
    
    <category term="orm" scheme="https://leetaogoooo.github.io/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Automated deployment of hexo via github action</title>
    <link href="https://leetaogoooo.github.io/2022/01/30/%E4%BD%BF%E7%94%A8%20github%20actions%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%20hexo%20%E5%8D%9A%E5%AE%A2/"/>
    <id>https://leetaogoooo.github.io/2022/01/30/%E4%BD%BF%E7%94%A8%20github%20actions%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%20hexo%20%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每年都要折腾一下自己的博客，今年准备把所有的博客再次迁移到静态博客 Hexo 中，配合 Github Action 实现，只需要一个浏览器就可以自动部署博客。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>整体思路很简单，在你的 github-pages 的项目建立两个 分支 <code>master</code> 和 <code>gh-pages</code>，在 <code>gh-pages</code> 分支上完成 <code>hexo</code> 的构建，然后将构建后的静态网页推送到 <code>master</code> 分支上</p><p><img src="https://raw.githubusercontent.com/LeetaoGoooo/leetaogoooo.github.io/images/%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png"></p><p>其中在 github actions 涉及的主要 action 为 <a href="https://github.com/JamesIves/github-pages-deploy-action">github-pages-deploy-action</a>，参考说明文档，需要使用到 <code>token</code> 或者 <code>ssh-key</code>，这里我使用到是前者，获取 token 的方法可以参考 <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">encrypted-secrets</a>，然后在你的 github-pages 仓库 <code>secrets</code> 设置一下 <code>token</code>，命名为 <code>ACCESS_TOKEN</code></p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span> <span class="string">CI/CD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发条件：在 push 到 gh-pages 分支后触发</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">gh-pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">blog-cicd:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">blog</span> <span class="string">build</span> <span class="string">&amp;</span> <span class="string">deploy</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">macos-latest</span> <span class="comment"># 系统环境，可以自由设置</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">codes</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">node</span></span><br><span class="line">      <span class="comment"># 设置 node.js 环境</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">node</span> <span class="string">modules</span></span><br><span class="line">      <span class="comment"># 设置包缓存目录，避免每次下载</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">~/.npm</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-node-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/package-lock.json&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">hexo</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="comment"># 下载 hexo-cli 脚手架及相关安装包</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install -g hexo-cli</span></span><br><span class="line"><span class="string">        npm install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">files</span></span><br><span class="line">      <span class="comment"># 编译 markdown 文件</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        hexo clean</span></span><br><span class="line"><span class="string">        hexo generate</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span> <span class="string">blog</span></span><br><span class="line">      <span class="comment"># 部署到 GitHub Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">BRANCH:</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">FOLDER:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure><p>这里略过了关于 hexo 的配置，如果对 hexo 的配置不太了解可以参考 <a href="https://hexo.io/zh-cn/">hexo官网</a>,到此，只要每次直接更新 gh-pages 就可以触发自动构建流程了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每年都要折腾一下自己的博客，今年准备把所有的博客再次迁移到静态博客 Hexo 中，配合 Github Action 实现，只需要一个浏览器就可以自动部署博客。&lt;/p&gt;</summary>
    
    
    
    
    <category term="github-action" scheme="https://leetaogoooo.github.io/tags/github-action/"/>
    
    <category term="hexo" scheme="https://leetaogoooo.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>functools.lru_cache 的正确用法</title>
    <link href="https://leetaogoooo.github.io/2022/01/26/functools.lru_cache%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/"/>
    <id>https://leetaogoooo.github.io/2022/01/26/functools.lru_cache%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/</id>
    <published>2022-01-26T09:29:53.000Z</published>
    <updated>2022-04-12T07:10:22.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>lru_cache 是 functools 库中的一个函数，它为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。</p></blockquote><p>从它的功能来说是一个不错的方法，可以在一定程度上提高函数的运行速度，但是它存在一个问题，<strong>当你用functools.lru_cache装饰器来装饰一个实例方法时，封装该方法的类的实例在持有它们的进程中永远不会被垃圾回收。</strong></p><span id="more"></span><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>接下来让我们通过一个简单的例子去论证上述的观点。（以下代码运行于 python3.6.8）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Number = TypeVar(<span class="string">&quot;Number&quot;</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">complex</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLruCache</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, delay: <span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line"></span><br><span class="line">self.delay = delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, *args: Number</span>) -&gt; Number:</span></span><br><span class="line"></span><br><span class="line">time.sleep(self.delay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting instance ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例</span></span><br><span class="line"></span><br><span class="line">test = TestLruCache(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计运行时长</span></span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">result = test.calculate(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;计算耗时 <span class="subst">&#123;end_time-start_time&#125;</span> s, result: <span class="subst">&#123;result&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">result = test.calculate(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;计算耗时 <span class="subst">&#123;end_time-start_time&#125;</span> s, result: <span class="subst">&#123;result&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们创建一个类，这个类有个 <code>calculate</code> 方法，这个方法使用 <code>lru_cache</code> 装饰，为了更好的体现 <code>lru_cache</code>的作用，加上了一个 <code>delay</code> 的参数，其中 <code>__del__</code> 的魔术方法作用就是当开始垃圾回收的时候，<code>__del__</code> 方法就会被执行。</p><p>接下来我们尝试运行该程序，看一下输出结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算耗时 2.0021407306194305 s, result: 3.</span><br><span class="line">计算耗时 4.209578037261963e-06 s, result: 3.</span><br><span class="line">Deleting instance ...</span><br></pre></td></tr></table></figure><p>从输出结果不难看的出，使用 <code>lru_cache</code> 后，第二次调用 <code>calculate</code> 方法，运行的时间降低了很多，不难理解，第二次我们请求的参数完全一样，所以结果直接从字典中就获取到了。但是需要注意到一点，在程序的生命周期中，<code>TestLruCache</code> 的实例被没有被垃圾回收。</p><p>上面的例子可能说服力还不够，没关系，接下来我们再看几个例子。</p><h2 id="垃圾回收没有生效"><a href="#垃圾回收没有生效" class="headerlink" title="垃圾回收没有生效"></a>垃圾回收没有生效</h2><p>如果我们通过 <code>python -i</code> 的方式执行上述的脚本，你就清晰地发现垃圾回收没有生效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ python3 -i test.py</span><br><span class="line">计算耗时 <span class="number">2.004133677983191</span> s, result: <span class="number">3.</span></span><br><span class="line">计算耗时 <span class="number">3.143970388919115e-06</span> s, result: <span class="number">3.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gc</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = <span class="literal">None</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure><p>在交互模式下，我将 <code>test</code> 赋值为 <code>None</code>，并且主动调用垃圾回收器，能看到 <code>gc.collect()</code> 的输出结果为 <code>22</code>，但是并没有看到 <code>__del__</code> 方法的输出，这说明程序里依然存在 <code>TestLruCache</code> 的实例引用，垃圾回收器并不能将对象成功的回收。</p><p>让我们排查一下究竟是谁还在引用实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -i test.py</span><br><span class="line"></span><br><span class="line">计算耗时 <span class="number">2.004039512015879</span> s, result: <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">计算耗时 <span class="number">3.3050309866666794e-06</span> s, result: <span class="number">3.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate.cache_info()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line">CacheInfo(hits=<span class="number">1</span>, misses=<span class="number">1</span>, maxsize=<span class="number">128</span>, currsize=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">2</span>, misses=<span class="number">1</span>, maxsize=<span class="number">128</span>, currsize=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate.cache_clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = <span class="literal">None</span></span><br><span class="line">Deleting instance ...</span><br></pre></td></tr></table></figure><p>上面的 <code>cache_info</code> 输出结果表明，这个缓存保存着实例的引用，除非手动清除。当我们手动清除缓存并将变量 <code>test</code> 重新分配为 <code>None</code> 时，垃圾收集器才会删除该实例。</p><p>除此之外，在这个例子里我们设置的 <code>maxsize</code> 是 <code>128</code>，表明最大缓存的结果个数是 <code>128</code> 个，一旦我们将 <code>maxsize</code> 置为 <code>None</code> 的话，LRU 特性将被禁用且缓存可无限增长。在这情况下将会很危险，一旦我们在一次请求中创建很多实例，这些实例不能为垃圾回收，一旦达到一定程序，必然会导致内存溢出，从而造成程序崩溃。</p><p>那么能不能解决这个问题呢？别着急，往下看</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>解决这个问题很简答，我们只需要让缓存成为实例的本地变量就行了，这样一来，从缓存到实例的引用就会随着实例一起被删除。看一下改造后的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">Number = TypeVar(<span class="string">&quot;Number&quot;</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">complex</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLruCache</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, delay: <span class="built_in">int</span> = <span class="number">1</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">self.delay = delay</span><br><span class="line">self.calculate = lru_cache(maxsize=<span class="number">128</span>)(self._calculate)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_calculate</span>(<span class="params">self, *args: Number</span>) -&gt; Number:</span></span><br><span class="line">time.sleep(self.delay)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting instance ...&quot;</span>)</span><br></pre></td></tr></table></figure><p>好了让我们验证一下改造后的程序是否可以:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -i test.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = TestLruCache(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.calculate.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">0</span>, misses=<span class="number">1</span>, maxsize=<span class="number">128</span>, currsize=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> gc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = <span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line">Deleting instance ...</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>注意到这次，我们不需要主动去清除缓存，但是需要显示的调用 <code>gc.collect()</code> 去执行垃圾回收。这是因为这种诡计创造了循环引用，垃圾回收需要做一些特殊的魔术来清除内存。在真正的代码中，Python 解释器会在后台为我们清理这些，而不需要我们调用垃圾回收。</p><h1 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h1><p>上面提到的问题，会对类方法和静态方法产生影响吗？<strong>答案是否定的</strong>，让我们验证一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*coding: utf-8 -* # test1.py</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">cls, delay: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"></span><br><span class="line">cls.delay = delay</span><br><span class="line">time.sleep(delay)</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting instance ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">test_1 = Test()</span><br><span class="line">test_2 = Test()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">result = test_1.test(<span class="number">2</span>)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;耗时 <span class="subst">&#123;end_time start_time&#125;</span> s, result: <span class="subst">&#123;result&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line">result = test_2.test(<span class="number">2</span>)</span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;耗时 <span class="subst">&#123;end_time start_time&#125;</span> s, result: <span class="subst">&#123;result&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure><p>同样的，我们在交互模式下验证结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python -i test1.py</span><br><span class="line">耗时 <span class="number">2.003696349042002</span> s, result: <span class="number">42.</span></span><br><span class="line">耗时 <span class="number">4.3199979700148106e-06</span> s, result: <span class="number">42.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_1 = <span class="literal">None</span></span><br><span class="line">Deleting instance ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_2 = <span class="literal">None</span></span><br><span class="line">Deleting instance ...</span><br></pre></td></tr></table></figure><p>同理我们也可以验证一下静态方法，基本上一样，这里就提供一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">cls, delay: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">cls.delay = delay</span><br><span class="line">time.sleep(delay)</span><br><span class="line"><span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Deleting instance ...&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.python.org/3.6/library/functools.html#functools.lru_cache">functools.lru_cache</a><br><a href="https://stackoverflow.com/questions/70409673/python-lru-cache-in-a-class-disregards-maxsize-limit-when-decorated-with-a-stati">Python LRU cache in a class disregards maxsize limit when decorated with a staticmethod or classmethod decorator</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;lru_cache 是 functools 库中的一个函数，它为函数提供缓存功能的装饰器，缓存 maxsize 组传入参数，在下次以相同参数调用时直接返回上一次的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从它的功能来说是一个不错的方法，可以在一定程度上提高函数的运行速度，但是它存在一个问题，&lt;strong&gt;当你用functools.lru_cache装饰器来装饰一个实例方法时，封装该方法的类的实例在持有它们的进程中永远不会被垃圾回收。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://leetaogoooo.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用 pre-commit 配合 black、isort 自动格式化 Python 文件</title>
    <link href="https://leetaogoooo.github.io/2021/12/30/lwp55SOlQ/"/>
    <id>https://leetaogoooo.github.io/2021/12/30/lwp55SOlQ/</id>
    <published>2021-12-30T00:18:00.000Z</published>
    <updated>2022-04-12T07:10:22.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为了保证 Python 的代码规范，在使用 <code>git commit</code> 提交代码之前，需要使用 blake、isort 工具对提交的文件进行格式化，如果提交的代码符合规法则 commit 成功，否则自动格式化文件，然后重新 commit</p></blockquote><p>整个工作流大概是这样子：</p><p><img src="https://www.leetao94.cn/post-images/1640823506631.png"></p><p>其中 <code>black</code> 是代码格式化工具，可以通过 <code>pip install black</code> 后直接使用，使用方法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black &#123;source_file_or_directory&#125;...</span><br></pre></td></tr></table></figure><p>同时也支持配置文件自定义规则，详细内容可以参考官方文档 <a href="https://black.readthedocs.io/en/stable/">The uncompromising code formatter — Black</a></p><p><code>isort</code>  则是用来规范 python 库的引入的，按字母顺序对 packages 进行排序，并自动分为不同的部分和类型，同样可以通过 <code>pip install isort</code> 后直接使用，使用方法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isort mypythonfile.py mypython file2.py</span><br></pre></td></tr></table></figure><p>和 <code>black</code> 一样也支持配置文件自定义规则，具体内容参考官网 <a href="https://pycqa.github.io/isort/">isort (pycqa.github.io)</a></p><p><code>pre-commit</code> 是整个工作流最重要的一环，<code>pre-commit</code> 是 <code>git-hooks</code> 中的一个重要的钩子，它在键入提交信息前运行。<strong>可以用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交。</strong> 上面提到的机制是整个工作流可以进行的关键。</p><p>完全可以自定义 <code>pre-commit</code> 钩子的，但是如果只是为了检验的话，可以使用现成的方案 <a href="https://github.com/pre-commit/pre-commit">pre-commit/pre-commit</a>,用 Python 构建，支持多语言的管理器。通过 <code>pre-commit</code> 这个库，简单地几步就可以实现自动化工作流。</p><ol><li>安装 pre-commit</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pre-commit</span><br></pre></td></tr></table></figure><p>然后通过 <code>pre-commit --version</code> 确定是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pre-commit --version</span><br><span class="line">pre-commit 2.16.0</span><br></pre></td></tr></table></figure><ol start="2"><li>添加 <code>.pre-commit-config.yaml</code> 的配置文件</li></ol><p>可以通过 <code>pre-commit sample-config</code> 生成一个默认的配置文件,这里贴一下关于 <code>black</code> 和 <code>isort</code> 的配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span>  </span><br><span class="line"><span class="bullet">-</span>   <span class="attr">repo:</span> <span class="string">https://github.com/psf/black</span>  </span><br><span class="line"> <span class="attr">rev:</span> <span class="number">21.</span><span class="string">12b0</span>  </span><br><span class="line"> <span class="attr">hooks:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">black</span>  </span><br><span class="line">  </span><br><span class="line"><span class="bullet">-</span>   <span class="attr">repo:</span> <span class="string">https://github.com/PyCQA/isort</span>  </span><br><span class="line"> <span class="attr">rev:</span> <span class="number">5.10</span><span class="number">.1</span>  </span><br><span class="line"> <span class="attr">hooks:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br></pre></td></tr></table></figure><p>支持的配置项很多，具体参考 <a href="https://pre-commit.com/#plugins">plugins</a></p><ol start="3"><li> 安装 git hooks 脚本</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pre-commit install</span><br><span class="line">pre-commit installed at .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p>然后就就大功告成了</p><p><img src="https://www.leetao94.cn/post-images/1640823519964.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为了保证 Python 的代码规范，在使用 &lt;code&gt;git commit&lt;/code&gt; 提交代码之前，需要使用 blake、isort 工具对提交的文件进行格式化，如果提交的代码符合规法则 commit 成功，否则自动格式化文件，然后重新 co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>类的自定注册以及应用场景</title>
    <link href="https://leetaogoooo.github.io/2021/12/25/3K1fxgdEp/"/>
    <id>https://leetaogoooo.github.io/2021/12/25/3K1fxgdEp/</id>
    <published>2021-12-25T02:38:21.000Z</published>
    <updated>2022-04-12T07:10:22.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 3.6 之前可以通过 <code>meta class</code> 去实现，3.6 之后可以通过 <code>__init_subclass__</code> 实现</p></blockquote><h2 id="meta-class"><a href="#meta-class" class="headerlink" title="meta class"></a><code>meta class</code></h2><p>通过 <code>meta class</code> 的 <code>__new__</code> 方法可以实现自动注册 <code>class</code> 的功能，原理很简单，就是通过元类去控制类的创建，在调用 <code>__new__</code>  方法的时候自动将 <code>class</code> 注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, attrs</span>):</span></span><br><span class="line">        newclass = <span class="built_in">super</span>(MetaClass, cls).__new__(cls, clsname, bases, attrs)</span><br><span class="line">        register(newclass)  <span class="comment"># 注册函数</span></span><br><span class="line">        <span class="keyword">return</span> newclass</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params">metaclass=MetaClass</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="init-subclass"><a href="#init-subclass" class="headerlink" title="__init_subclass__"></a><code>__init_subclass__</code></h2><p><code>__init_subclass__</code> 是 3.6 后引入的一个新的特性，一个 hook，可以让所有的子类在创建之后执行一些初始化的操作，通过这个特性我们就可以更简单地实现上述通过元类实现的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init_subclass_</span>(<span class="params">cls, **kwargs</span>):</span></span><br><span class="line"><span class="built_in">super</span>().__init_subclass(**kwargs)</span><br><span class="line">register(cls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>(<span class="params">ParentClass</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是 <code>__init_subclass__</code>  <strong>没有非关键字参数</strong>。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>代码存在如下的逻辑:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> category == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">handle_a()</span><br><span class="line"><span class="keyword">elif</span> cateogory == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">handle_b()</span><br><span class="line"><span class="keyword">elif</span> category == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">handle_c()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">handle_else()</span><br></pre></td></tr></table></figure><p>存在很多都处理逻辑，每个逻辑可能由不同的开发人员编写，全部放到一个代码块中，可以预见随着分支的增多，这部分代码会变得越来越庞大，不利于后期维护，所以最简单的方案，存在一个 dict 保存 <code>category</code> 和 处理方法的映射关系:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">category_to_func = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: handle_a</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以将最初的代码简化为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> category_to_func.get(category)()</span><br></pre></td></tr></table></figure><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>基于上面的思路，可以写出最简单的方法，让大家自行编写自己的处理方法，然后在 <code>category_to_func</code> 中统一注册自己的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">category_to_func = &#123;</span><br><span class="line"><span class="string">&#x27;a&#x27;</span>: handle_a <span class="comment"># A 撰写注册</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span>: handle_b <span class="comment"># B 撰写注册</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子没有任何问题，但是不够优雅，开发人员撰写了自己的处理方法之后，还要去指定的地方注册自己的方法，开发体验不太好。<br>如果存在一种方式，开发人员只需要撰写处理方法，代码可以自定注册就更好了。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>通过上面的自注册的方法，让子类继承父类，然后将其自动注册到全局当中，这样子开发人员只需要关注自己的业务实现就可以了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.python.org/dev/peps/pep-0487/">PEP 487 – Simpler customisation of class creation</a><br><a href="https://stackoverflow.com/questions/5189232/how-to-auto-register-a-class-when-its-defined">python - How to auto register a class when it’s defined - Stack Overflow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在 3.6 之前可以通过 &lt;code&gt;meta class&lt;/code&gt; 去实现，3.6 之后可以通过 &lt;code&gt;__init_subclass__&lt;/code&gt; 实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;meta-class&quot;&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://leetaogoooo.github.io/tags/python/"/>
    
    <category term="pep" scheme="https://leetaogoooo.github.io/tags/pep/"/>
    
  </entry>
  
  <entry>
    <title>Django 自定义 SearchFilter兼容空格搜索</title>
    <link href="https://leetaogoooo.github.io/2021/12/09/GLNcAwN1I/"/>
    <id>https://leetaogoooo.github.io/2021/12/09/GLNcAwN1I/</id>
    <published>2021-12-09T00:29:49.000Z</published>
    <updated>2022-04-12T07:10:22.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Django 自带的 SearchFilter 是不支持空格搜索的，如果需要支持空格搜索并且保留之前的搜索功能则需要自定义 SearchFilter。</p><h1 id="自定义-SearchFilter"><a href="#自定义-SearchFilter" class="headerlink" title="自定义 SearchFilter"></a>自定义 SearchFilter</h1><p>继承 SeachFilter 然后实现 <code>get_search_terms</code> 方法，如果同时支持 space 然后又可以保持之前的搜索特性呢？</p><p>简单的做法就是，对输入的参数进行校验，如果只有含有空格就返回空格，否则就执行之前的搜索逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanSerachBothCharFilter</span>(<span class="params">SearchFilter</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_search_terms</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        params = request.query_params.get(self.search_param, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="comment"># 判断原来的参数是否有只有空格</span></span><br><span class="line">        only_space = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(params) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(params.strip()) == <span class="number">0</span>:</span><br><span class="line">            only_space = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        params = params.replace(<span class="string">&#x27;\x00&#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># strip null characters</span></span><br><span class="line">        params = params.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> only_space:</span><br><span class="line">            <span class="keyword">return</span> [params]</span><br><span class="line">        <span class="keyword">return</span> params.split()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Django 自带的 SearchFilter 是不支持空格搜索的，如果需要支持空格搜索并且保留之前的搜索功能则需要自定义 SearchFi</summary>
      
    
    
    
    
    <category term="python" scheme="https://leetaogoooo.github.io/tags/python/"/>
    
    <category term="django" scheme="https://leetaogoooo.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>pep 544 Protocols: Structural subtyping (static duck typing)</title>
    <link href="https://leetaogoooo.github.io/2021/11/29/HwmFtxua0/"/>
    <id>https://leetaogoooo.github.io/2021/11/29/HwmFtxua0/</id>
    <published>2021-11-29T00:17:04.000Z</published>
    <updated>2022-04-12T07:10:22.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://www.python.org/dev/peps/pep-0484">PEP 484</a>  中引入的 Typing hints (类型提示) 可以用来为静态类型检查器和其他第三方工具指定类型元数据。但是在，<a href="https://www.python.org/dev/peps/pep-0484">PEP 484</a>  只指定了名义子类型的语义。在这个 <a href="https://www.python.org/dev/peps/pep-0544/">PEP 544</a> 中，指定了协议类的静态和运行时语义，这将为结构性子类型（静态鸭子类型）提供一个支持。</p><h2 id="什么是鸭子类型-Duck-Typing-？"><a href="#什么是鸭子类型-Duck-Typing-？" class="headerlink" title="什么是鸭子类型(Duck Typing)？"></a>什么是鸭子类型(Duck Typing)？</h2><blockquote><p>If it walks like a duck and it quacks like a duck, then it must be a duck。</p></blockquote><p>简单地说，”如果它走路像鸭子，叫起来像鸭子，那它一定是鸭子“。</p><p>在编程中这就意味着当我们编写接收特定输入的函数时，我们只需要关心该函数输入的行为、属性，而不是该函数输入的显式类型。</p><blockquote><p>例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为”鸭子”的对象，并调用它的”走”和”叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的”走”和”叫”方法。— 百度百科</p></blockquote><p>那么如何在 Python 中实现“鸭子类型”呢？</p><h1 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h1><p>现在有这样子场景，我们需要编写一个函数去计算一个拥有边长(len_side)的物体的周长，伪代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> calcute_circumference(shape):</span><br><span class="line">circumference <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> side <span class="keyword">in</span> shape.len_side: <span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> 遍历边长</span><br><span class="line">circumference <span class="operator">+</span><span class="operator">=</span> side</span><br><span class="line"><span class="keyword">return</span> circumference <span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> 周长</span><br></pre></td></tr></table></figure><p>从伪代码不难看出，我们不关心是什么的物体，我们只需要保证这个物体可以有一个 len_side（列表） 字段就可以了。</p><p>现在我们可以借由 <code>Protocol</code> 去实现它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjWithSideLen</span>(<span class="params">Protocol</span>):</span></span><br><span class="line">side_len: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcute_circumference</span>(<span class="params">shape: ObjWithSideLen</span>):</span></span><br><span class="line">circumference = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> side <span class="keyword">in</span> shape.side_len:</span><br><span class="line">circumference += side</span><br><span class="line"><span class="keyword">return</span> circumference</span><br></pre></td></tr></table></figure><p>从上面的例子不难看出 <code>Protocol</code> 有点类似 Java 中的接口，只需要在函数上使用它，并不需要去关注输入的参数的具体类型。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>我们还可以配合使用 <code>typing</code> 中的 <code>TypeVar</code> 实现泛型参数化，让我们的函数更加抽象化，只要符合协议，无论什么类型的输入都可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjWithSideLen</span>(<span class="params">Protocol</span>):</span></span><br><span class="line">side_len: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>, bound=ObjWithSideLen)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcute_circumference</span>(<span class="params">shape: T</span>) -&gt; T:</span></span><br><span class="line">circumference = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> side <span class="keyword">in</span> shape.side_len:</span><br><span class="line">circumference += side</span><br><span class="line">shape.circumference = circumference</span><br><span class="line"><span class="keyword">return</span> shape</span><br></pre></td></tr></table></figure><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>上述的例子都可以借由 Python 中的 ABCs 去实现的，但是两者的侧重点有所不同，由于篇幅有限，在下一篇文章，让我们仔细对比一下两者的的区别。</p><ul><li>参考文章  <a href="https://docs.python.org/zh-cn/3/library/typing.html">python-typing</a>  <a href="https://www.daan.fyi/writings/python-protocols">Static Duck Typing in Python with Protocols</a>  <a href="https://www.python.org/dev/peps/pep-0544/">PEP 544</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot;&gt;PEP 484&lt;/a&gt;  中引入的</summary>
      
    
    
    
    
    <category term="Python" scheme="https://leetaogoooo.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>git commit 规范以及校验方案</title>
    <link href="https://leetaogoooo.github.io/2021/11/19/KS62tWWwN/"/>
    <id>https://leetaogoooo.github.io/2021/11/19/KS62tWWwN/</id>
    <published>2021-11-18T23:55:16.000Z</published>
    <updated>2022-04-12T07:10:22.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用 Git 作为版本控制工具时，每次文件发生修改的时候提交都需要 <code>git commit</code> 命令去记录本次的修改，否则就不允许提交，显然 <code>git commit</code>  是一个重要的环节，因此制定一个 Git Commit 规范是有必要的，否则就会出现混乱的提交信息，这里腾讯某团队的规范作为例子，然后通过一定的手段去帮助我们把这个规范落到实处。</p><p>目的：</p><ul><li>统一团队 <code>Git commit</code> 日志标准，便于后续代码 review，版本发布以及日志自动化生成等等。</li><li>统一团队的 Git 工作流，包括分支使用、tag 规范、issue 等</li></ul><h1 id="Git-commit-日志参考案例"><a href="#Git-commit-日志参考案例" class="headerlink" title="Git commit 日志参考案例"></a><strong>Git commit 日志参考案例</strong></h1><ul><li><a href="https://github.com/angular/angular">angular</a></li><li><a href="https://github.com/cpselvis/commit-message-test-project">commit-message-test-project</a></li><li><a href="https://github.com/istanbuljs/babel-plugin-istanbul">babel-plugin-istanbul</a></li><li><a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a></li></ul><h1 id="总体方案"><a href="#总体方案" class="headerlink" title="总体方案"></a><strong>总体方案</strong></h1><p><img src="https://www.leetao94.cn/post-images/1637279828697.png" alt="来自 feflow 的 git commit 规范"></p><h1 id="Git-commit日志基本规范"><a href="#Git-commit日志基本规范" class="headerlink" title="Git commit日志基本规范"></a><strong>Git commit日志基本规范</strong></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><h2 id="type-类型"><a href="#type-类型" class="headerlink" title="type 类型"></a><strong>type 类型</strong></h2><blockquote><p>type代表某次提交的类型，比如是修复一个bug还是增加一个新的feature</p></blockquote><ul><li>feat： 新增 feature</li><li>fix: 修复 bug</li><li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等</li><li>style: 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑</li><li>refactor: 代码重构，没有加新功能或者修复 bug</li><li>perf: 优化相关，比如提升性能、体验</li><li>test: 测试用例，包括单元测试、集成测试等</li><li>chore: 改变构建流程、或者增加依赖库、工具等</li><li>revert: 回滚到上一个版本</li></ul><h2 id="格式要求"><a href="#格式要求" class="headerlink" title="格式要求"></a><strong>格式要求</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标题行：50个字符以内，描述主要变更内容</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等</span></span><br><span class="line"><span class="comment"># * 他如何解决这个问题? 具体描述解决问题的步骤</span></span><br><span class="line"><span class="comment"># * 是否存在副作用、风险?</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 尾部：如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。</span></span><br></pre></td></tr></table></figure><h1 id="校验方案"><a href="#校验方案" class="headerlink" title="校验方案"></a>校验方案</h1><p>node 项目已经有比较成熟的方案，这里以 Python 项目为例，考虑实际使用的便利性，希望可以可以实现以下的目的：</p><ol><li>成员在<strong>本地执行 git commit 的命令时就完成校验</strong>，通过则允许执行 <code>git push</code> 否则则需要重新提交 commit 的信息。</li><li>提交到 gitlab，由服务端完成再次校验</li></ol><h2 id="本地校验"><a href="#本地校验" class="headerlink" title="本地校验"></a>本地校验</h2><h3 id="git-hooks"><a href="#git-hooks" class="headerlink" title="git hooks"></a>git hooks</h3><p>Git 在执行 <code>git init</code> 进行初始化的时候，会在 <code>.git/hooks</code> 目录下生成一系列 hooks 脚本:</p><p><img src="https://www.leetao94.cn/post-images/1637279929295.png" alt="git-hooks"></p><p>从上图可以看到每个脚本的后缀都是以 <code>.sample</code> 结尾的，在这个时候，脚本是不会自动执行的。我们需要把后缀去掉之后才会生效，即将 <code>pre-commit.sample</code> 变成 <code>pre-commit</code> 才会起作用。由于只是对 commit msg 做校验，所以只需要使用 <code>commit-msg</code> 脚本即可。</p><h3 id="commit-msg-脚本"><a href="#commit-msg-脚本" class="headerlink" title="commit-msg 脚本"></a>commit-msg 脚本</h3><p>在 <code>commit-msg</code> hooks 中完成对 commit 消息校验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前提交的 commit msg</span></span><br><span class="line">commit_msg=`cat $<span class="number">1</span>`</span><br><span class="line"></span><br><span class="line">msg_re=<span class="string">&quot;^(feat|fix|docs|style|refactor|perf|test|workflow|build|ci|chore|release|workflow)(\(.+\))?: .&#123;1,100&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! $commit_msg =~ $msg_re ]]</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">&quot;\n不合法的 commit 消息提交格式，请使用正确的格式\n &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;</span></span><br><span class="line">    <span class="comment"># 异常退出</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>将上述脚本保持在项目所在对 <code>.git/hooks</code> 目录下命名为 <code>commit-msg</code>,然后执行 <code>chmod</code> 命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x .git/hooks/commit-msg</span><br></pre></td></tr></table></figure><h3 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h3><ol><li>不符合规法的 commit msg</li></ol><p><img src="https://www.leetao94.cn/post-images/1637280036579.png" alt="不合规的git-commit-msg"></p><ol start="2"><li>符合规范的 commit-msg</li></ol><p><img src="https://www.leetao94.cn/post-images/1637280050146.png" alt="合规的git-commit-msg"></p><h1 id="服务端校验"><a href="#服务端校验" class="headerlink" title="服务端校验"></a>服务端校验</h1><p>Git 在服务端也同样有一些 hooks:</p><ul><li><code>pre-receive</code></li><li><code>update</code></li><li><code>post-receive</code></li></ul><p>每个 hooks 的具体功能可以参考 <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks#_server_side_hooks">Server-Side Hooks</a> ，其中 <code>pre-receive</code> 和 <code>update</code> 均符合使用场景，唯一区别是<strong>用户同时推送到多个分支时， update 针对每个分支都会被触发执行，而 <code>pre-receive</code> 只执行一次。</strong></p><h2 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在任何文件被更新时，如果<code>$GIT_DIR/hooks/pre-receive</code> 存在并且是可执行的文件，则 pre-receive 会被无参数触发执行一次，正常 pre-receive 触发执行的时候会接收如下的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha1-old SP sha1-new SP refname LF</span><br></pre></td></tr></table></figure><p>其中 sha1-old 为多次 commit 的最早一次的 commit 的 id，而 sha1-new 则是最新一次的 id。除此之外，git push 的时候还会传递其他的信息，可以参考 <a href="https://git-scm.com/docs/git-receive-pack#_pre_receive_hook">pre-receive-hooks</a> 。</p><h3 id="校验方法"><a href="#校验方法" class="headerlink" title="校验方法"></a>校验方法</h3><p>通过 <code>git log old-commit-ID new-commit-ID -pretty=format:%s</code> 提取出俩个 commit 之间的所有 commit-msg 然后逐一校验。</p><p><img src="https://www.leetao94.cn/post-images/1637280064019.png"></p><p>考虑易用性，用 golang 构建校验脚本</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line"><span class="string">&quot;regexp&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CommitTypeConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">commitTypeList []<span class="keyword">string</span></span><br><span class="line">strictMode     <span class="keyword">bool</span> <span class="comment">// 严格模式下将校验所有的提交信息格式(多 commit 下)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkFailedMeassge = <span class="string">`</span></span><br><span class="line"><span class="string">Commit message 格式校验失败❌</span></span><br><span class="line"><span class="string">Commit message 格式必须符合下述规则:</span></span><br><span class="line"><span class="string">    ^(\w+)(\(\w+\))*: (.+)|^Merge\ branch(.*)|^Merge\ remote-tracking branch(.*)</span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string">    feat(test): test commit style check.`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ZERO_COMMIT = <span class="string">&quot;0000000000000000000000000000000000000000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">config := CommitTypeConfig&#123;</span><br><span class="line">commitTypeList: []<span class="keyword">string</span>&#123;<span class="string">&quot;feat&quot;</span>, <span class="string">&quot;fix&quot;</span>, <span class="string">&quot;docs&quot;</span>, <span class="string">&quot;style&quot;</span>, <span class="string">&quot;refactor&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;chore&quot;</span>, <span class="string">&quot;perf&quot;</span>, <span class="string">&quot;hotfix&quot;</span>&#125;,</span><br><span class="line">strictMode:     <span class="literal">true</span>&#125;</span><br><span class="line">input, _ := ioutil.ReadAll(os.Stdin)</span><br><span class="line">param := strings.Fields(<span class="keyword">string</span>(input))</span><br><span class="line"><span class="comment">// allow branch/tag delete</span></span><br><span class="line"><span class="keyword">if</span> param[<span class="number">1</span>] == ZERO_COMMIT &#123;</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isExists(<span class="string">&quot;pre-receive.json&quot;</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;检测到存在配置文件，加载配置文件规则💪&quot;</span>)</span><br><span class="line">file, _ := ioutil.ReadFile(<span class="string">&quot;pre-receive.json&quot;</span>)</span><br><span class="line">tmpConfig := CommitTypeConfig&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]<span class="keyword">byte</span>(file), &amp;tmpConfig)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;成功加载配置文件规则😊&quot;</span>)</span><br><span class="line">config = tmpConfig</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;加载配置文件规则失败，使用默认规则文件😭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;开始加载默认配置文件规则💪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">commitMsg := getCommitMsg(param[<span class="number">0</span>], param[<span class="number">1</span>])</span><br><span class="line">checkCommitMsg(commitMsg, config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCommitMsg</span><span class="params">(oldCommitID <span class="keyword">string</span>, commitID <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;git log %s..%s --pretty=format:%%s&quot;</span>, oldCommitID, commitID)</span><br><span class="line"><span class="keyword">if</span> oldCommitID == ZERO_COMMIT &#123;</span><br><span class="line">s = fmt.Sprintf(<span class="string">&quot;git rev-list --pretty=format:%%s $(git for-each-ref --format=&#x27;%%(refname)&#x27; refs/heads/* | sed &#x27;s/^/\\^/g&#x27;) %s | grep -v ^commit&quot;</span>, commitID)</span><br><span class="line">&#125;</span><br><span class="line">commitMsg := strings.Split(runCmd(s), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> commitMsg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkFailed</span><span class="params">(tmpStr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, <span class="string">&quot;===================================&quot;</span>)</span><br><span class="line">fmt.Fprintln(os.Stderr, tmpStr)</span><br><span class="line">fmt.Fprintln(os.Stderr, <span class="string">&quot;===================================&quot;</span>)</span><br><span class="line">fmt.Fprintln(os.Stderr, checkFailedMeassge)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isExists</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">_, err := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 规则校验</span></span><br><span class="line"><span class="comment">/// @commitMsg []string 提交的信息数组</span></span><br><span class="line"><span class="comment">/// @config 规则配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkCommitMsg</span><span class="params">(commitMsg []<span class="keyword">string</span>, config CommitTypeConfig)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> CommitMessagePattern = <span class="string">`^(\w+)(\(\w+\))*: (.+)|^Merge\ branch(.*)|^Merge\ remote-tracking branch(.*)`</span></span><br><span class="line"><span class="keyword">var</span> commitMsgReg = regexp.MustCompile(CommitMessagePattern)</span><br><span class="line"><span class="keyword">for</span> _, tmpStr := <span class="keyword">range</span> commitMsg &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Trim(tmpStr, <span class="string">&quot; &quot;</span>) == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">commitTypes := commitMsgReg.FindAllStringSubmatch(tmpStr, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(commitTypes) != <span class="number">1</span> &#123;</span><br><span class="line">checkFailed(tmpStr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasPrefix(tmpStr, <span class="string">&quot;Merge&quot;</span>) &amp;&amp; !stringInSlice(commitTypes[<span class="number">0</span>][<span class="number">1</span>], config.commitTypeList) &#123;</span><br><span class="line">checkFailed(tmpStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !config.strictMode &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;恭喜🎉，commit message 校验通过✅&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;恭喜🎉，commit message 校验通过✅&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringInSlice</span><span class="params">(a <span class="keyword">string</span>, list []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> list &#123;</span><br><span class="line"><span class="keyword">if</span> b == a &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCmd</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, s)</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">r, err := cmd.Output()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Run command failed, [%s]\nerr: %s&quot;</span>, s, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时支持添加配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;commitTypeList&quot;</span>:[ <span class="comment">// 支持的 commitType</span></span><br><span class="line">        <span class="string">&quot;feat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fix&quot;</span>,</span><br><span class="line">        <span class="string">&quot;docs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;style&quot;</span>,</span><br><span class="line">        <span class="string">&quot;refactor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;chore&quot;</span>,</span><br><span class="line">        <span class="string">&quot;perf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hotfix&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;strictMode&quot;</span>: <span class="literal">true</span> <span class="comment">// 严格模式会校验多次 commit 的所有信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器配置-pre-receive"><a href="#服务器配置-pre-receive" class="headerlink" title="服务器配置 pre-receive"></a>服务器配置 pre-receive</h2><p>参考 <a href="https://docs.gitlab.com/ee/administration/server_hooks.html">Server Hooks</a> 需要将编译后 <code>pre-receive</code> 放到制定的 repository 的钩子目录即可，具体步骤如下:</p><ol><li>找到对应 repository 的 <code>.git</code> 目录</li><li>在该目录下创建 <code>custom_hooks</code> 的目录</li><li>将编译后的 <code>pre-receive</code> 放到该目录下(如果有配置文件也上传到该目录下)</li><li>通过 <code>chmod +x pre-receive</code> 让该文件可执行，同时将该文件的用户组切换为 <code>git:git</code></li><li>推送代码验证结果</li></ol><p><img src="https://www.leetao94.cn/post-images/1637280076441.png" alt="pre-receive-校验通过结果"></p><ul><li>参考链接<ul><li><a href="https://git-scm.com/docs/git-receive-pack#_pre_receive_hook">pre-receive-hooks</a></li><li><a href="https://docs.gitlab.com/ee/administration/server_hooks.html">Server Hooks</a></li><li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks#_server_side_hooks">Server-Side Hooks</a></li><li><a href="https://feflowjs.com/zh/guide/rule-git-commit.html">Git Commit 规范</a></li><li><a href="https://segmentfault.com/a/1190000009048911">git commit 规范指南</a></li><li><a href="https://git-scm.com/docs/git-commit">git-commit</a></li><li><a href="https://zhuanlan.zhihu.com/p/182553920">如何规范你的Git commit？</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在使用 Git 作为版本控制工具时，每次文件发生修改的时候提交都需要 &lt;code&gt;git commit&lt;/code&gt; 命令去记录本次的修改，</summary>
      
    
    
    
    
    <category term="gitflow" scheme="https://leetaogoooo.github.io/tags/gitflow/"/>
    
  </entry>
  
  <entry>
    <title>滴滴行程分享 Api</title>
    <link href="https://leetaogoooo.github.io/2021/09/25/8p6b-bIBf/"/>
    <id>https://leetaogoooo.github.io/2021/09/25/8p6b-bIBf/</id>
    <published>2021-09-25T08:38:40.000Z</published>
    <updated>2022-04-12T07:10:22.019Z</updated>
    
    <content type="html"><![CDATA[<p>分享一个很久之前写的一个关于滴滴行程的脚本，脚本的主要功能是根据滴滴行程分享的 url 获取订单情况，通过定时轮询还可以获取乘客到目的地的距离和时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@File    :   didi.py    </span></span><br><span class="line"><span class="string">@Description：滴滴行程分享 Api</span></span><br><span class="line"><span class="string">@Modify Time      @Author    @Version    @Description</span></span><br><span class="line"><span class="string">------------      -------    --------    -----------</span></span><br><span class="line"><span class="string">2021/5/29 8:47 上午   leetao      1.0         None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib.parse <span class="keyword">as</span> urlparse</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, asdict</span><br><span class="line"></span><br><span class="line">_header = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DidiOrderParams</span>:</span></span><br><span class="line">    uid: <span class="built_in">str</span></span><br><span class="line">    oid: <span class="built_in">str</span></span><br><span class="line">    sign: <span class="built_in">str</span></span><br><span class="line">    productType: <span class="built_in">str</span></span><br><span class="line">    carProductid: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_didi</span>(<span class="params">url: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">    <span class="keyword">return</span> url.startswith(<span class="string">&quot;https://z.didi.cn&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_order_params</span>(<span class="params">url: <span class="built_in">str</span></span>) -&gt; DidiOrderParams:</span></span><br><span class="line">    resp = requests.get(url, allow_redirects=<span class="literal">False</span>, headers=_header)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">302</span>:</span><br><span class="line">        redirect_url = resp.headers[<span class="string">&#x27;location&#x27;</span>]</span><br><span class="line">        parsed = urlparse.urlparse(redirect_url)</span><br><span class="line">        params = parse_qs(parsed.query)</span><br><span class="line">        <span class="keyword">return</span> DidiOrderParams(uid=params[<span class="string">&#x27;uid&#x27;</span>], oid=params[<span class="string">&#x27;oid&#x27;</span>], sign=params[<span class="string">&#x27;sign&#x27;</span>],</span><br><span class="line">                               productType=params[<span class="string">&#x27;productType&#x27;</span>], carProductid=params[<span class="string">&#x27;carProductid&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_order_info</span>(<span class="params">order_param: DidiOrderParams</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    resp = requests.get(<span class="string">&#x27;https://common.diditaxi.com.cn/webapp/sharetrips/page/getOrderStatus&#x27;</span>,</span><br><span class="line">                        params=asdict(order_param), headers=_header)</span><br><span class="line">    <span class="keyword">assert</span> resp.status_code == <span class="number">200</span></span><br><span class="line">    resp_json = resp.json()</span><br><span class="line">    <span class="keyword">assert</span> resp_json[<span class="string">&#x27;errno&#x27;</span>] == <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;本次行程 \n 起点：<span class="subst">&#123;resp_json[<span class="string">&quot;fromAddress&quot;</span>]&#125;</span> \n 终点: <span class="subst">&#123;resp_json[<span class="string">&quot;toAddress&quot;</span>]&#125;</span> \n 您的行程管家将定时为您播报行程情况&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_driver_loc</span>(<span class="params">order_param: DidiOrderParams</span>):</span></span><br><span class="line">    resp = requests.get(<span class="string">&#x27;https://common.diditaxi.com.cn/webapp/sharetrips/page/getDriverLoc&#x27;</span>,params=asdict(order_param),</span><br><span class="line">                        headers=_header)</span><br><span class="line">    <span class="keyword">assert</span> resp.status_code == <span class="number">200</span></span><br><span class="line">    resp_json = resp.json()</span><br><span class="line">    <span class="keyword">assert</span> resp_json[<span class="string">&#x27;errno&#x27;</span>] == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;etaDistance&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> resp_json:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;本次行程已经结束&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;距离目的地还有：<span class="subst">&#123;resp_json[<span class="string">&quot;etaDistance&quot;</span>]&#125;</span> 公里，预计还有：<span class="subst">&#123;resp_json[<span class="string">&quot;etaTime&quot;</span>]&#125;</span> 分钟&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分享一个很久之前写的一个关于滴滴行程的脚本，脚本的主要功能是根据滴滴行程分享的 url 获取订单情况，通过定时轮询还可以获取乘客到目的地的距离和时间&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    
    <category term="Python" scheme="https://leetaogoooo.github.io/tags/Python/"/>
    
    <category term="爬虫" scheme="https://leetaogoooo.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>开启人生的新的阶段</title>
    <link href="https://leetaogoooo.github.io/2021/09/23/jVldsA6pc/"/>
    <id>https://leetaogoooo.github.io/2021/09/23/jVldsA6pc/</id>
    <published>2021-09-23T10:55:35.000Z</published>
    <updated>2022-04-12T07:10:22.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要不要换个新的城市开始新的生活？</p></blockquote><p>这是今年一直盘旋在我脑海里的想法。想法到落地中间并不是简单的 1 + 1 的问题，俩者之间隔着巨大的鸿沟，因为这意味着可能一切都需要重新开始。</p><p>从零开始并不是想象的那么简单，需要离开从大学开始就一直生活的城市，一个对我来说生活了八年多的地方，离开熟悉的天空、熟悉的街道、熟悉的人和熟悉的工作环境。记得上次有这种想法的时候，是刚毕业一年多的时候，也就是四年前，很遗憾，那个时候一个人的勇气并不能够支撑着我背起行囊潇洒地离开这里。</p><p>是的，没错，这次离开，是两个人一起。两个人能够在这种事情上达成一致的想法，是何其幸运的事情。在这里这些年最大的收获，就是收获了爱情，在开始新的阶段的时候，有人与我同行。</p><p>勇气是打开新的阶段的钥匙的话，那么找工作就是到达终点前的“拦路虎”了。</p><p>由于自己还处于在职状态，所以所有的面试基本上都只能约在下班之后了，自然面试前都准备工作也同样只能放在下班之后了。人生最让人觉得（有趣）无奈的事情就是，你越不想事情多的时候，基本上你的事情就会越来越多。恰巧开始准备复习的时候，负责的项目需要演示汇报，而这个时候郑州又赶上了暴雨加疫情，所谓的“涝疫结核”，一个多月的足不出户的生活，还有爷爷的离开。</p><p>因为疫情的原因，有一两年没有回老家了，没想到再次回去就是收到爷爷病重的消息，紧接着就是在暴雨和疫情期间被告知爷爷离开的消息，我记得那天的没有下雨，天比较阴沉，我坐在沙发上接到老爸打来的电话，说的什么我已经记不清了，我只记得挂断电话之后，眼泪不由自主地流了下来。</p><p>那个时候，我才切身体会道什么叫做紧绷着的弦，所有的事情都在不停地拉扯着神经。整个人变得有点焦虑，焦虑到夜里睡不着，焦虑到一个多月瘦了6-7斤，焦虑到茶饭不思。很难想象如果这个时候没有我的另一半一直陪着我，我该如何度过这一阶段。</p><p>潮起日落，日子总是一天一天在指尖划过。度过最难过的一段时光，后面的面试除了时间上比较紧凑，面试后面还是比较顺利的。工作了五年之后，再次收获了一份满意的 offer，很快就要去新的城市开始新的生活了。你说我现在的心情是什么样的，有向往，也有紧张，向往全新的生活，对新的开始难免有点彷徨和紧张。</p><p>最近处于离职的阶段，也算是闲了下来，可以偶尔跑跑步、看看书，前几天晚上还把藏在柜子里深处的尤克里里翻了出来，久违的轻松惬意，希望 2021 年接下来的日子都顺顺利利的。</p><p><img src="https://www.leetao94.cn/post-images/1632399527176.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;要不要换个新的城市开始新的生活？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是今年一直盘旋在我脑海里的想法。想法到落地中间并不是简单的 1 + 1 的问题，俩者之间隔着巨大的鸿沟，因为这意味着可能一切都需要重新开始。&lt;/p&gt;
&lt;p&gt;从零开始并不是</summary>
      
    
    
    
    
    <category term="朝花夕拾" scheme="https://leetaogoooo.github.io/tags/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Python 中 assert 的最佳实践</title>
    <link href="https://leetaogoooo.github.io/2021/09/16/VXzqfuZ3G/"/>
    <id>https://leetaogoooo.github.io/2021/09/16/VXzqfuZ3G/</id>
    <published>2021-09-16T12:12:21.000Z</published>
    <updated>2022-04-12T07:10:22.043Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文连接： <a href="https://archive.is/5GfiG">When to use assert</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>assert</code> 又称为断言，在 Python 代码中经常被使用，但是显然也存在滥用的情况。那么在什么时候使用 <code>assert</code> 呢？又或者 <code>assert</code> 的最佳实践是怎么样的呢？</p><h1 id="assert-的使用"><a href="#assert-的使用" class="headerlink" title="assert 的使用"></a>assert 的使用</h1><p>Python 的 <code>assert</code> 通常用来检查一个条件，如果它是真的，则不做任何事情，如果它是假的，则引发一个 AssertionError，并给出一个可选的错误信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">py&gt; x = <span class="number">23</span></span><br><span class="line">py&gt; <span class="keyword">assert</span> x &gt; <span class="number">0</span>, <span class="string">&quot;x is not zero or negative&quot;</span></span><br><span class="line">py&gt; <span class="keyword">assert</span> x%<span class="number">2</span> == <span class="number">0</span>, <span class="string">&quot;x is not an even number&quot;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: x <span class="keyword">is</span> <span class="keyword">not</span> an even number</span><br></pre></td></tr></table></figure><p>许多人喜欢通过 <code>assert</code> 来简单地快速地触发异常，比如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, <span class="built_in">int</span>):</span><br><span class="line">    <span class="keyword">raise</span> AssertionError(<span class="string">&quot;not an int&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过检验参数，并抛出 <code>AssertionError</code> ，实际上，这种做法是错误的，并且还很危险。正确的做法是应该抛出一个 <code>TypeError</code> 。</p><p>之所以危险是英文，<code>assert</code>  有一个特性：<strong>使用 <code>-O</code> 或 <code>-OO</code> 优化指令去运行 Python 的话，它会被被编译掉，而永远不会被执行。</strong>当你能够正确使用 <code>assert</code> 时，这是会是一个 feature，但当使用不当的话，则会导致代码在使用 <code>-O</code> 标志运行时出问题。</p><p>所以应该在什么情况下使用 assert 呢</p><h1 id="什么时候使用-assert"><a href="#什么时候使用-assert" class="headerlink" title="什么时候使用 assert"></a>什么时候使用 assert</h1><p>在下面这四种情况下都可以考虑使用 <code>assert</code>:</p><ul><li>防御性编程。</li><li>对程序逻辑进行运行时检查。</li><li>契约检查（如前条件和后条件）。</li><li>程序不变性</li><li>检查文件</li></ul><p>对断言的看法各不相同，它可以看作是一种对代码正确性的信心的表现形式吧。如果你确定你的代码毫无问题的话，显然断言（<code>assert</code>）是没有任何意义的，完全可以把这些断言移除；如果你确定断言可能会被触发，那你也完全可以不用断言（<code>assert</code>），毕竟它在某些情况下肯定会编译掉，导致你的检查被跳过。</p><p>介于这两种情况之间的情况才是有趣的，当你确定代码是正确的，但又不完全确定的时候。<br>你确定代码是正确的，但又不是<strong>绝对确定</strong>。有可能漏掉一些场景，在这种情况下，通过断言（assert）进行运行时检查有助于我们尽早的发现错误。</p><p><strong>断言的另一个用途是检查程序的不变量</strong>。所谓的不变量就是一些你可以依赖的真实条件，除非一个错误导致它变成假的。如果有一个bug，最好能尽早发现所以我们要对它进行测试，但我们不想因为这样的测试而降低代码的速度。但我们不想因为这些测试而使代码变慢。因此我们可以通过可在开发中打开而在生产中关闭断言（assert）。</p><p>不变量的一个例子是，如果你的函数预期一个数据库连接是 open，并承诺它在返回时仍然是open，这就是函数的一个不变式。open 就是该函数的一个不变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_function</span>(<span class="params">arg</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> DB.closed()</span><br><span class="line">    ... <span class="comment"># code goes here</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> DB.closed()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>断言也是很好的检查性评论，而不是写一个评论：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># when we reach here, we know that n &gt; 2</span></span><br><span class="line"><span class="comment"># 我们可以通过将其转换为断言来确保在运行时对其进行检查</span></span><br><span class="line"><span class="keyword">assert</span> n &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>断言也是防御性编程的一种形式</strong>。你不是在保护现在的代码中的错误，而是在保护以后引入错误的变化。理想情况下，单元测试会发现这些错误，但是实际上，即使存在测试，它们也是往往是不完整的。有可能在几周内都没有人注意到构建机器人，或者有的时候在提交代码前忘记运行测试。有一个内部检查是防止错误潜入的另一道防线，特别是阻止那些会导致代码故障和返回错误结果的静默错误。</p><p>假设你有个代码中有 if…elif 代码块，这个时候你是知道这些分支对应了哪些变量，并且了解逻辑是什么:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># target is expected to be one of x, y, or z, and nothing else.</span></span><br><span class="line"><span class="keyword">if</span> target == x:</span><br><span class="line">    run_x_code()</span><br><span class="line"><span class="keyword">elif</span> target == y:</span><br><span class="line">    run_y_code()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    run_z_code()</span><br></pre></td></tr></table></figure><p>假设这个代码现在是完全正确的。但它会一直正确吗？需求改变了,代码也会改变。现在要求改变为当 target == w，执行 run_w_code。如果我们改变了设置目标的代码，但忽略了改变这个代码块，它将错误地调用 run_z_code()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target = w</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> target == x:</span><br><span class="line">    run_x_code()</span><br><span class="line"><span class="keyword">elif</span> target == y:</span><br><span class="line">    run_y_code()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    run_z_code()</span><br></pre></td></tr></table></figure><p>最好是把这段代码写成防御性的，哪怕之后有变化，它也是要么是正确的，要么立即失败。</p><p>写代码块一开始加注释是很好的习惯，但是通常时间久了，我们就没有阅读和更新注释的习惯。有可能注释很快就会被淘汰。但通过一个断言，我们既可以记录这个块的假设，也可以在断言检验没通过的时候直接抛出错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> target <span class="keyword">in</span> (x, y, z)</span><br><span class="line"><span class="keyword">if</span> target == x:</span><br><span class="line">    run_x_code()</span><br><span class="line"><span class="keyword">elif</span> target == y:</span><br><span class="line">    run_y_code()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> target == z</span><br><span class="line">    run_z_code()</span><br></pre></td></tr></table></figure><p>断言既是防御性编程，也是经过检查的文档，下面这个代码会更好一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> target == x:</span><br><span class="line">    run_x_code()</span><br><span class="line"><span class="keyword">elif</span> target == y:</span><br><span class="line">    run_y_code()</span><br><span class="line"><span class="keyword">elif</span> target == z:</span><br><span class="line">    run_z_code()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># This can never happen. But just in case it does...</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;an unexpected error occurred&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>契约设计是另一种对断言的不错的应用</strong>。在按契约设计中，我们认为函数与它们的调用者签订了 “契约”。<br>例如,”如果你传递给我一个非空的字符串，我保证返回该字符串的第一个的第一个字符转换成大写字母”。</p><p>如果这个契约被函数或调用它的代码所破坏,代码就是有问题的。我们说，函数有预设条件（即<br>参数的约束）和后置条件（返回结果的约束） 因此，这个函数可能被代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_upper</span>(<span class="params">astring</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(astring, <span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">len</span>(astring) &gt; <span class="number">0</span></span><br><span class="line">    result = astring[<span class="number">0</span>].upper()</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(result, <span class="built_in">str</span>) <span class="keyword">and</span> <span class="built_in">len</span>(result) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> result == result.upper()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>契约设计的目的是，在一个正确的程序中，前条件和后条件总是成立的。当我们发布无错误的程序并将其投入生产时，我们可以安全地删除这些断言。</p><h1 id="什么时候不使用assert"><a href="#什么时候不使用assert" class="headerlink" title="什么时候不使用assert"></a>什么时候不使用assert</h1><ul><li>永远不要用它们来测试用户提供的数据，或者用于在任何情况下必须进行检查的地方。</li><li>不要用断言来检查任何你认为在你的程序的正常使用中可能失败的东西。断言是为特殊失败条件。你的用户不应该看到 <code>AssertionError</code>。如果他们看到了，这就是一个需要修复的错误。</li><li>特别是，不要因为 <code>assert</code> 比一个测试和 raise 短就使用它。</li><li>不要用它们来检查公共库的输入参数函数的输入参数，因为你无法控制调用者，也不能保证它不会破坏函数的契约。</li><li>不要将 <code>assert</code> 用于任何你期望恢复的错误。 换句话说，你没有理由在生产代码中捕捉一个<code>AssertionError</code> 异常。</li><li>不要使用太多的断言，以至于它们掩盖了代码。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文连接： &lt;a href=&quot;https://archive.is/5GfiG&quot;&gt;When to use assert&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="python" scheme="https://leetaogoooo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Dataclasses 、 Attrs 和 Pydantic</title>
    <link href="https://leetaogoooo.github.io/2021/09/13/KGYoGNer0/"/>
    <id>https://leetaogoooo.github.io/2021/09/13/KGYoGNer0/</id>
    <published>2021-09-13T10:14:35.000Z</published>
    <updated>2022-04-12T07:10:22.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python3.7 引入了一个新的模块那就是 <code>dataclasses</code>，早在 3.6 版本的时候我就通过安装 <code>dataclasses</code> 三方库体验了一波，那么为什么要用 <code>dataclasses</code> 呢？</p><h2 id="为什么使用-dataclasses"><a href="#为什么使用-dataclasses" class="headerlink" title="为什么使用 dataclasses"></a>为什么使用 dataclasses</h2><p>一个简单的场景，当你想定义一个对象的属性的时候，比如一本书，通常你会这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, price: <span class="built_in">float</span>, author:<span class="built_in">str</span> = <span class="string">&quot;佚名&quot;</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.price = price</span><br><span class="line">        self.author = author</span><br></pre></td></tr></table></figure><p>如果在不定义 <code>__repr__</code> 的情况下，初始化这个对象，并输出的话:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>book = Book(<span class="string">&#x27;桃子&#x27;</span>,<span class="number">10.0</span>,author=<span class="string">&#x27;桃子&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book</span><br><span class="line">&lt;__main__.Book <span class="built_in">object</span> at <span class="number">0x10b69cbb0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(book)</span><br><span class="line"><span class="string">&#x27;&lt;__main__.Book object at 0x10b69cbb0&gt;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(book)</span><br><span class="line"><span class="string">&#x27;&lt;__main__.Book object at 0x10b69cbb0&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>显然输出不够友好，对于属性比较少的对象，定义一个 <code>__repr__</code> 并不太麻烦，但是一旦需要定义的对象很多或者属性很多的情况下，这样子做就显得略微麻烦了一点。这个时候 <code>dataclasses</code> 就派上用场了。</p><h1 id="dataclasses"><a href="#dataclasses" class="headerlink" title="dataclasses"></a>dataclasses</h1><p>我们用 <code>dataclasses</code> 把 <code>Book</code> 改造一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">name:<span class="built_in">str</span></span><br><span class="line">price:<span class="built_in">float</span></span><br><span class="line">author:<span class="built_in">str</span> = <span class="string">&#x27;桃子&#x27;</span></span><br></pre></td></tr></table></figure><p>然后简单验证一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass,asdict,astuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@dataclass</span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line"><span class="meta">... </span>    name:<span class="built_in">str</span></span><br><span class="line"><span class="meta">... </span>    price:<span class="built_in">float</span></span><br><span class="line"><span class="meta">... </span>    author:<span class="built_in">str</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book1 = Book(name=<span class="string">&#x27;桃子1&#x27;</span>,price=<span class="number">10.0</span>,author=<span class="string">&#x27;桃子1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book1</span><br><span class="line">Book(name=<span class="string">&#x27;桃子1&#x27;</span>, price=<span class="number">10.0</span>, author=<span class="string">&#x27;桃子1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asdict(book1)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;桃子1&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">10.0</span>, <span class="string">&#x27;author&#x27;</span>: <span class="string">&#x27;桃子1&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astuple(b1)</span><br><span class="line">(<span class="string">&#x27;桃子1&#x27;</span>, <span class="number">12.0</span>, <span class="string">&#x27;桃子&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>dataclasses</code> 甚至还具备 <code>asdict</code> 函数可以将对象转成 <code>dict</code>，也存在 <code>astuple</code> 可以将对象转成<code>tupple</code> ,是不是很方便,但是还不够，有时候我们对不同对参数进行一定对校验，很遗憾 <code>dataclasses</code> 并不能做到，这个时候就需要看 <code>attrs</code> 和 <code>pydantic</code> 了。</p><p>除此之外，<code>attrs</code> 和 <code>pydantic</code> 还有其他的 <code>dataclasses</code> 不具备的特性，见下表：</p><p><img src="https://www.leetao94.cn/post-images/1631528189775.png"></p><h1 id="attrs-vs-pydantic"><a href="#attrs-vs-pydantic" class="headerlink" title="attrs vs pydantic"></a>attrs vs pydantic</h1><p>attrs 和 pydantic 都需要通过 pip 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install attrs</span><br><span class="line">pip install pydantic</span><br></pre></td></tr></table></figure><h2 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h2><h3 id="attrs-中的-validators"><a href="#attrs-中的-validators" class="headerlink" title="attrs 中的 validators"></a>attrs 中的 validators</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import attr</span><br><span class="line"></span><br><span class="line">@attr.s</span><br><span class="line">class Book:</span><br><span class="line">    name: str = attr.ib(default=None)</span><br><span class="line">    price:<span class="built_in">float</span> = attr.ib(default=None,validator=attr.validators.instance_of(<span class="built_in">float</span>))</span><br><span class="line">    author: str = attr.ib(default=<span class="string">&#x27;桃子&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    @price.validator</span><br><span class="line">    def more_than_zero(self, attribute, value):</span><br><span class="line">        <span class="keyword">if</span> not value &gt; 0:</span><br><span class="line">            raise ValueError(<span class="string">&quot;价格不能少于 0 元!&quot;</span>)</span><br><span class="line"></span><br><span class="line">book = Book(name=<span class="string">&#x27;attrs&#x27;</span>,price=-1.0,author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行一下，验证一下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test_attrs.py&quot;</span>, line 14, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    book = Book(name=<span class="string">&#x27;attrs&#x27;</span>,price=-1.0,author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;&lt;attrs generated init __main__.Book&gt;&quot;</span>, line 6, <span class="keyword">in</span> __init__</span><br><span class="line">  File <span class="string">&quot;D:\workspace\python\test\venv\lib\site-packages\attr\_make.py&quot;</span>, line 2975, <span class="keyword">in</span> __call__</span><br><span class="line">    v(inst, attr, value)</span><br><span class="line">  File <span class="string">&quot;test_attrs.py&quot;</span>, line 12, <span class="keyword">in</span> more_than_zero</span><br><span class="line">    raise ValueError(<span class="string">&quot;价格不能少于 0 元!&quot;</span>)</span><br><span class="line">ValueError: 价格不能少于 0 元!</span><br></pre></td></tr></table></figure><h3 id="pydantic-中的-validators"><a href="#pydantic-中的-validators" class="headerlink" title="pydantic 中的 validators"></a>pydantic 中的 validators</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel,validator, ValidationError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name:<span class="built_in">str</span></span><br><span class="line">    price:<span class="built_in">float</span></span><br><span class="line">    author:<span class="built_in">str</span> = <span class="string">&#x27;桃子&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @validator(<span class="params"><span class="string">&quot;price&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">more_than_zero</span>(<span class="params">cls, v</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(v,<span class="built_in">float</span>)</span><br><span class="line">        <span class="keyword">if</span> v &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;价格不能少于 0 元!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">book = Book(name=<span class="string">&#x27;attrs&#x27;</span>,price=-<span class="number">1.0</span>,author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同样的验证一下结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test_pydantic.py&quot;</span>, line <span class="number">15</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    book = Book(name=<span class="string">&#x27;attrs&#x27;</span>,price=-<span class="number">1.0</span>,author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;pydantic\main.py&quot;</span>, line <span class="number">406</span>, <span class="keyword">in</span> pydantic.main.BaseModel.__init__</span><br><span class="line">pydantic.error_wrappers.ValidationError: <span class="number">1</span> validation error <span class="keyword">for</span> Book</span><br><span class="line">price</span><br><span class="line">  价格不能少于 <span class="number">0</span> 元! (<span class="built_in">type</span>=value_error)</span><br></pre></td></tr></table></figure><p>除了 validators ，attrs 和 pydantic 还同时具有  converters（转换器） 功能。</p><h2 id="converters"><a href="#converters" class="headerlink" title="converters"></a>converters</h2><p>转换器也是一个十分实用的功能，所谓的转换器就是在将参数在传递到 <code>__init__</code>  之前，将它按照需求转换成所需格式的数据。</p><p>最常见的就是将 str 转成 datetime 格式，attrs 和 pydantic 在转换器的实现上有所区别：</p><h3 id="attrs-中-的转换器"><a href="#attrs-中-的转换器" class="headerlink" title="attrs 中 的转换器"></a>attrs 中 的转换器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> attr</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conver_to_datetime</span>(<span class="params">user_input</span>) -&gt;  datetime:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(user_input,<span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">return</span> datetime.strptime(user_input, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(user_input,datetime):</span><br><span class="line">        <span class="keyword">return</span> user_input</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">&quot;不支持的参数类型，仅支持:str 和 datetime&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@attr.s</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">    <span class="comment"># ... 省略</span></span><br><span class="line">    publish_date: datetime = attr.ib(default=<span class="literal">None</span>, converter=conver_to_datetime)</span><br><span class="line"></span><br><span class="line">book = Book(name=<span class="string">&#x27;attrs&#x27;</span>,price=<span class="number">1.0</span>,author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>,publish_date=<span class="string">&#x27;2021-09-13 00:00:00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book)</span><br></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book(name=<span class="string">&#x27;attrs&#x27;</span>, price=<span class="number">1.0</span>, author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>, publish_date=datetime.datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>不难看出，str 类型的字符串被成功转化了。</p><h3 id="pydantic-中的转换器"><a href="#pydantic-中的转换器" class="headerlink" title="pydantic 中的转换器"></a>pydantic 中的转换器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel,validator</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line"><span class="comment"># 省略...</span></span><br><span class="line">    publish_date: datetime</span><br><span class="line"></span><br><span class="line"><span class="meta">    @validator(<span class="params"><span class="string">&quot;publish_date&quot;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conver_to_datetime</span>(<span class="params">cls, user_input</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(user_input,<span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">return</span> datetime.strptime(user_input, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(user_input,datetime):</span><br><span class="line">            <span class="keyword">return</span> user_input</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;不支持的参数类型，仅支持:str 和 datetime&quot;</span>)</span><br><span class="line"></span><br><span class="line">book = Book(name=<span class="string">&#x27;attrs&#x27;</span>,price=<span class="number">1.0</span>,author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span>, publish_date=<span class="string">&#x27;2021-09-13 16:03:00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(book)</span><br></pre></td></tr></table></figure><p>验证结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&#x27;attrs&#x27;</span> price=<span class="number">1.0</span> author=<span class="string">&#x27;hynek Hynek Schlawack&#x27;</span> publish_date=datetime.datetime(<span class="number">2021</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>从上面的代码不难看出，attrs 本身内置 converter 参数，可以通过传递内置函数或者自定义函数实现转化器的功能，而 pydantic 则需要借助 validator 去实现，在这一点上 pydantic 还是稍微逊色 attrs。</p><p>除了上面提到的两个功能，attrs 和 pydantic 都具备 <code>immutable</code> 的方法用来修饰属性，从而实现属性不可修改。</p><p>attrs 还具备 <code>slots</code> 和 <code>programmatic creation</code> 有兴趣的可以进一步阅读官方文档。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上面的例子，不难看出 pydantic 有下面几个问题：</p><ol><li>pydantic 不支持位置参数</li><li>pydantic 的输出有点奇怪，没有带上类名</li><li>pydantic 不支持 <code>slots</code> 和 <code>programmatic creation</code></li><li><a href="https://github.com/samuelcolvin/pydantic/issues/2605">pydantic 不支持 Collection 类型</a> </li></ol><p>在参考文章中还提到了 pydantic 对 unions 的策略有问题，不容易定制，并且对定制的（非）结构化的支持很弱。</p><p>所以如果有复杂的需求的话，建议使用 <code>attrs</code> ，只是想简单的呈现对象的属性的话，可以考虑用 <code>dataclasses</code> 。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html">dataclasses vs attrs vs Pydantic</a></p><p><a href="https://zhuanlan.zhihu.com/p/34963159">attrs 和 Python3.7 的 dataclasses</a></p><p><a href="https://threeofwands.com/why-i-use-attrs-instead-of-pydantic/amp/?__twitter_impression=true">Why I use attrs instead of pydantic</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Python3.7 引入了一个新的模块那就是 &lt;code&gt;dataclasses&lt;/code&gt;，早在 3.6 版本的时候我就通过安装 &lt;co</summary>
      
    
    
    
    
    <category term="python" scheme="https://leetaogoooo.github.io/tags/python/"/>
    
    <category term="Python标准库" scheme="https://leetaogoooo.github.io/tags/Python%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 支持 PDF 等文件搜索</title>
    <link href="https://leetaogoooo.github.io/2021/09/08/07txYm7YT/"/>
    <id>https://leetaogoooo.github.io/2021/09/08/07txYm7YT/</id>
    <published>2021-09-08T10:28:54.000Z</published>
    <updated>2022-04-12T07:10:22.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>默认情况下 es 是不支持 pdf、doc 等文档的搜索的，但是可以通过安装 <code>Ingest attachment plugin</code> 插件来使得 es 提取通用格式的文件，从而可以实现搜索的功能。</p><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><h2 id="安装-Ingest-attachment-plugin"><a href="#安装-Ingest-attachment-plugin" class="headerlink" title="安装 Ingest attachment plugin"></a>安装 Ingest attachment plugin</h2><p>安装很简单，通过 <code>elasticsearch-plugin</code> 可以直接进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch-plugin install ingest-attachment</span><br></pre></td></tr></table></figure><blockquote><p>Ingest attachment plugin 允许 Elasticsearch 通过使用 Apache 文本提取库 Tika 提取通用格式（例如：PPT，XLS 和 PDF）的文件附件。Apache Tika 工具包可从一千多种不同的文件类型中检测并提取元数据和文本。所有这些文件类型都可以通过一个界面进行解析，从而使 Tika 对搜索引擎索引，内容分析，翻译等有用。需要注意的是，源字段必须是 Base64 编码的二进制，如果不想增加在 Base64 之间来回转换的开销，则可以使用 CBOR 格式而不是 JSON，并将字段指定为字节数组而不是字符串表示形式，这样处理器将跳过 Base64 解码。</p></blockquote><h3 id="创建-attachment-pipeline"><a href="#创建-attachment-pipeline" class="headerlink" title="创建 attachment pipeline"></a>创建 attachment pipeline</h3><p>通过 kibana 的开发工具进行请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT _ingest/pipeline/pdfattachment</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Extract attachment information encoded in Base64 with UTF-8 charset&quot;</span>,</span><br><span class="line">  <span class="string">&quot;processors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;attachment&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;file&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;acknowledged&quot;</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示创建成功，接下来就是验证上传 pdf 以及搜索功能了。</p><h3 id="转换并上传PDF文件的内容到Elasticsearch中"><a href="#转换并上传PDF文件的内容到Elasticsearch中" class="headerlink" title="转换并上传PDF文件的内容到Elasticsearch中"></a>转换并上传PDF文件的内容到Elasticsearch中</h3><p>对于 Ingest attachment plugin 来说，它的数据必须是 Base64 的。这里为了快速创建，我们通过一个 bash 脚本去处理用来测试的 pdf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line"></span><br><span class="line">encodedPdf=`cat sample.pdf | base64`</span><br><span class="line"></span><br><span class="line">json=<span class="string">&quot;&#123;\&quot;file\&quot;:\&quot;<span class="variable">$&#123;encodedPdf&#125;</span>\&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$json</span>&quot;</span> &gt; json.file</span><br><span class="line"></span><br><span class="line">curl -X POST <span class="string">&#x27;http://localhost:9200/pdf-test1/_doc?pipeline=pdfattachment&amp;pretty&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d @json.file</span><br></pre></td></tr></table></figure><p>上传成功会返回如下的结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;pdf-test1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1oVSxHsB1ubIHqCXIbPU&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span> : 1,</span><br><span class="line">  <span class="string">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : 2,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span> : 1,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span> : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;_seq_no&quot;</span> : 0,</span><br><span class="line">  <span class="string">&quot;_primary_term&quot;</span> : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果出现提示下述提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;statusCode&quot;</span>: 400,</span><br><span class="line"><span class="string">&quot;error&quot;</span>: <span class="string">&quot;Bad Request&quot;</span>,</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Payload content length greater than maximum allowed: 1048576&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明上传的文件大小超过了 Kibana 默认的上限（默认 1M），修改 kibana 的配置 <code>kibana.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.maxPayloadBytes:</span> <span class="string">&quot;209715200&quot;</span></span><br></pre></td></tr></table></figure><h1 id="查看索引并搜索"><a href="#查看索引并搜索" class="headerlink" title="查看索引并搜索"></a>查看索引并搜索</h1><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><p>通过下面的命令可以查看 pdf-test1 的索引情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET pdf-test1/_search</span><br></pre></td></tr></table></figure><p>结果如下图<br><img src="https://www.leetao94.cn/post-images/1631096996349.png"></p><p>其中 <code>_source</code> 里有个 <code>content</code> 字段，就是 pdf 的内容，结果如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: &#123;</span><br><span class="line"> <span class="attr">&quot;file&quot;</span>:<span class="string">&quot;...&quot;</span>,</span><br><span class="line"><span class="attr">&quot;attachment&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;2021-08-18T07:29:34Z&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;content_type&quot;</span>: <span class="string">&quot;application/pdf&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;language&quot;</span>: <span class="string">&quot;lt&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;2021-07(copy)&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>file</code> 就是 base64 格式的内容，<code>content</code> 则包含了 pdf 的内容，如果不想要 <code>file</code> 则可以通过 <code>remove processor</code> 去除这个字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT _ingest/pipeline/pdfattachment</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Extract attachment information encoded in Base64 with UTF-8 charset&quot;</span>,</span><br><span class="line">  <span class="string">&quot;processors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;attachment&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;file&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;remove&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;file&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>通过在 kibana 的开发工具执行下述命令，验证一下搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET pdf-test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;attachment.content&quot;</span>: <span class="string">&quot;5G&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/sanduzxcvbnm/p/12624935.html">Elasticsearch：如何对PDF文件进行搜索</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;默认情况下 es 是不支持 pdf、doc 等文档的搜索的，但是可以通过安装 &lt;code&gt;Ingest attachment plugin&lt;</summary>
      
    
    
    
    
    <category term="Elasticsearch" scheme="https://leetaogoooo.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Docker 搭建 Elasticsearch + Kibana + IK 中文分词</title>
    <link href="https://leetaogoooo.github.io/2021/09/07/Dxqjjq53O/"/>
    <id>https://leetaogoooo.github.io/2021/09/07/Dxqjjq53O/</id>
    <published>2021-09-07T10:26:33.000Z</published>
    <updated>2022-04-12T07:10:22.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装启动-Elasticsearch"><a href="#安装启动-Elasticsearch" class="headerlink" title="安装启动 Elasticsearch"></a>安装启动 Elasticsearch</h1><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create elastic</span><br><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:<span class="number">7.14</span>.<span class="number">0</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -d --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:7.14.0</span></span><br></pre></td></tr></table></figure><h1 id="安装启动-Kibana"><a href="#安装启动-Kibana" class="headerlink" title="安装启动 Kibana"></a>安装启动 Kibana</h1><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/kibana/kibana:<span class="number">7.14</span>.<span class="number">0</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -d --name kib01-test --net elastic -p 5601:5601 -e <span class="string">&quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot;</span> docker.elastic.co/kibana/kibana:7.14.0</span></span><br></pre></td></tr></table></figure><p>启动完成之后访问 <a href="http://localhost:5601/"><code>http://localhost:5601</code></a> 即可，默认是英文，配置中文可以参考</p><h2 id="Kibana-汉化"><a href="#Kibana-汉化" class="headerlink" title="Kibana 汉化"></a>Kibana 汉化</h2><p>在 <code>kibana.yml</code> 中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i18n.locale: <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure><p>然后重启 kibana 即可</p><p>配置完成后重启服务，界面如下图：</p><p><img src="https://www.leetao94.cn/post-images/1631010579381.png"></p><h1 id="安装-IK-中文分词"><a href="#安装-IK-中文分词" class="headerlink" title="安装 IK 中文分词"></a>安装 IK 中文分词</h1><p>es 中本身自带英文分词，但是实际业务需要存在中文分词的场景，所以手动安装中文分词插件。</p><h2 id="下载-IK-分词插件"><a href="#下载-IK-分词插件" class="headerlink" title="下载 IK 分词插件"></a>下载 IK 分词插件</h2><p>从 github 上根据不同的 es 版本下载对应的 ik 插件压缩包</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><h2 id="在-es-的-plugins-解压"><a href="#在-es-的-plugins-解压" class="headerlink" title="在 es 的 plugins 解压"></a>在 es 的 plugins 解压</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-es-plugins/plugins/ &amp;&amp; mkdir ik</span><br><span class="line">unzip elasticsearch-analysis-ik-<span class="number">7.14</span>.<span class="number">0</span>.zip</span><br></pre></td></tr></table></figure><p>然后重新启动 es，这里我是使用 docker 启动 es 的，所以先通过 <code>docker cp</code> 的命令将插件复制到容器中的</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp es.zip container-id:/usr/share/elasticsearch/plugins/es</span><br></pre></td></tr></table></figure><h1 id="重启-es"><a href="#重启-es" class="headerlink" title="重启 es"></a>重启 es</h1><p>重启 es 的服务，如果成功加载插件，控制台会有如下的输出:</p><p><img src="https://www.leetao94.cn/post-images/1631010619965.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装启动-Elasticsearch&quot;&gt;&lt;a href=&quot;#安装启动-Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;安装启动 Elasticsearch&quot;&gt;&lt;/a&gt;安装启动 Elasticsearch&lt;/h1&gt;&lt;figure c</summary>
      
    
    
    
    
    <category term="Elasticsearch" scheme="https://leetaogoooo.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Type hinting may cause cyclic imports</title>
    <link href="https://leetaogoooo.github.io/2021/07/05/type-hinting-may-cause-cyclic-imports/"/>
    <id>https://leetaogoooo.github.io/2021/07/05/type-hinting-may-cause-cyclic-imports/</id>
    <published>2021-07-04T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.054Z</updated>
    
    <content type="html"><![CDATA[<p>Recently I was working on rss3 SDK. In order to facilitate development, I just make a python version of the reference <a href="https://github.com/NaturalSelectionLabs/RSS3-SDK-for-JavaScript">JavaScript  SDK</a>, which means the usage should be pretty similar between both.</p><h2 id="Make-a-Python-version"><a href="#Make-a-Python-version" class="headerlink" title="Make a Python version"></a>Make a Python version</h2><p>What’s  more, to make a clear code,I use type hinting in the new project. However, there is a code snippet in JavaScript version:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># index.ts</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RSS3</span> </span>&#123;</span><br><span class="line">    <span class="attr">options</span>: IOptions;</span><br><span class="line">    persona: Persona;</span><br><span class="line">    file: File;</span><br><span class="line">    profile: Profile;</span><br><span class="line">    items: Items;</span><br><span class="line">    item: Item;</span><br><span class="line">    links: Links;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options: IOptions</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.options = options;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.file = <span class="keyword">new</span> File(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.persona = <span class="keyword">new</span> Persona(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.profile = <span class="keyword">new</span> Profile(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> Items(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.item = <span class="keyword">new</span> Item(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.links = <span class="keyword">new</span> Links(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># file.ts</span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    private main: Main;</span><br><span class="line">    private list: &#123;</span><br><span class="line">        [key: string]: RSS3IContent;</span><br><span class="line">    &#125; = &#123;&#125;;</span><br><span class="line">    private dirtyList: &#123;</span><br><span class="line">        [key: string]: number;</span><br><span class="line">    &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">main: Main</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.main = main;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Yes, the two files refer to each other. Actually, it happens on many other files. When I turned this into Python version:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RSS3</span>:</span></span><br><span class="line">...</span><br><span class="line">    persona: Persona</span><br><span class="line">    file: File_</span><br><span class="line">    profile: Profile</span><br><span class="line">    items: Items</span><br><span class="line">    items: Item</span><br><span class="line">    links: Links</span><br><span class="line"></span><br><span class="line"><span class="comment"># file.py</span></span><br><span class="line"><span class="keyword">from</span> .index <span class="keyword">import</span> RSS3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    rss3: RSS3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rss3: RSS3</span>):</span></span><br><span class="line">        self.rss3 = rss3</span><br></pre></td></tr></table></figure><h2 id="circular-import"><a href="#circular-import" class="headerlink" title="circular import"></a>circular import</h2><p>It didn’t seem any errors, but when I started testing the problems appeared.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E   ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;RSS3&#x27;</span> <span class="keyword">from</span> partially initialized module <span class="string">&#x27;rss3.src.index&#x27;</span> (most likely due to a circular <span class="keyword">import</span>) </span><br></pre></td></tr></table></figure><p>how to solve this problem ? Don’t worry, <a href="https://www.python.org/dev/peps/pep-0484/#runtime-or-type-checking">PEP 484</a> has given a solution.</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><blockquote><p>When a type hint contains names that have not been defined yet, that definition may be expressed as a string literal, to be resolved later.</p></blockquote><p>So we can modify our code like the following:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    rss3: <span class="string">&#x27;RSS3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rss3: <span class="string">&#x27;RSS3&#x27;</span></span>):</span></span><br><span class="line">        self.rss3 = rss3</span><br></pre></td></tr></table></figure><p>That’s okay already.</p><blockquote><p>Sometimes there’s code that must be seen by a type checker (or other static analysis tools) but should not be executed. For such situations the typing module defines a constant, TYPE_CHECKING, that is considered True during type checking (or other static analysis) but False at runtime.</p></blockquote><p>Modify out code again:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> TYPE_CHECKING:</span><br><span class="line">    <span class="keyword">from</span> .index <span class="keyword">import</span> RSS3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    rss3: <span class="string">&#x27;RSS3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rss3: <span class="string">&#x27;RSS3&#x27;</span></span>):</span></span><br><span class="line">        self.rss3 = rss3</span><br></pre></td></tr></table></figure><h2 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more"></a>What’s more</h2><p>if we are using Python 3.7+, we can at least skip having to provide an explicit string annotation by taking advantage of <a href="https://www.python.org/dev/peps/pep-0563/">PEP 563</a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TYPE_CHECKING</span><br><span class="line"><span class="keyword">if</span> TYPE_CHECKING:</span><br><span class="line">    <span class="keyword">from</span> .index <span class="keyword">import</span> RSS3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>:</span></span><br><span class="line">    rss3: <span class="string">&#x27;RSS3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, rss3: <span class="string">&#x27;RSS3&#x27;</span></span>):</span></span><br><span class="line">        self.rss3 = rss3</span><br></pre></td></tr></table></figure><p>The <code>from __future__  import annotations</code> import will make all type hints be strings and skip evaluating them.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.python.org/dev/peps/pep-0484/#forward-references">PEP 484 – Type Hints</a></p><p><a href="https://stackoverflow.com/questions/39740632/python-type-hinting-without-cyclic-imports">Python type hinting without cyclic imports</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Recently I was working on rss3 SDK. In order to facilitate development, I just make a python version of the reference &lt;a href=&quot;https://gi</summary>
      
    
    
    
    
    <category term="Python" scheme="https://leetaogoooo.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Github Action 自动构建 Flutter  Android Apk</title>
    <link href="https://leetaogoooo.github.io/2021/05/22/Github%20Action%20%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%20Flutter%20%20Android%20Apk/"/>
    <id>https://leetaogoooo.github.io/2021/05/22/Github%20Action%20%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%20Flutter%20%20Android%20Apk/</id>
    <published>2021-05-21T16:00:00.000Z</published>
    <updated>2022-04-12T07:10:22.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间用 Flutter 做了一个开源的项目 <a href="https://github.com/lt94/RSSAid">RSSAid</a>,因为需要打包 apk，在此之前一直是在本地签名打包的。后来和别人交流了一下，想起来可以用 Github Action 构建持续化集成，自动打包。然后就研究了一下，最后完成了根据 tag 版本自动生成 apk 的 workflows。</p><h1 id="Workflows"><a href="#Workflows" class="headerlink" title="Workflows"></a>Workflows</h1><p>自动化构建脚本如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.yml</span></span><br><span class="line"><span class="comment"># 自动构建 Apk</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Test,</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Release</span> <span class="string">apk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作流程触发的时机，这里是当一个版本标签推送到仓库时触发</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">v*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个工作流程需要执行的任务</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">process:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">all</span> <span class="string">process</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># 这个任务的步骤</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 拉取项目代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="comment"># 建立 java 环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Java</span> <span class="string">JDK</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-java@v1.4.3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">java-version:</span> <span class="string">&quot;12.x&quot;</span></span><br><span class="line">      <span class="comment"># 建立 Flutter 环境</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Flutter</span> <span class="string">action</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">subosito/flutter-action@v1.4.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">channel:</span> <span class="string">&quot;stable&quot;</span></span><br><span class="line">          <span class="attr">flutter-version:</span> <span class="string">&quot;1.22.4&quot;</span></span><br><span class="line">      <span class="comment"># 下载项目依赖</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">flutter</span> <span class="string">pub</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$ENCODED_KEYSTORE</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-di</span> <span class="string">&gt;</span> <span class="string">android/app/keystore.jks</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ENCODED_KEYSTORE:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ENCODED_KEYSTORE</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="comment"># 打包 APK</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">flutter</span> <span class="string">build</span> <span class="string">apk</span> <span class="string">--release</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">KEYSTORE_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEYSTORE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">KEY_ALIAS:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEY_ALIAS</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">KEY_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.KEY_PASSWORD&#125;&#125;</span></span><br><span class="line">      <span class="comment"># 发布到 Release</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Release</span> <span class="string">apk</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">ncipollo/release-action@v1.5.0</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">artifacts:</span> <span class="string">&quot;build/app/outputs/apk/release/*.apk&quot;</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.RELEASE_TOKEN</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h1><p>脚本中有很多环境变量，都需要实现定义好，在项目的 secrets 中添加上。</p><h2 id="RELASE-TOKEN"><a href="#RELASE-TOKEN" class="headerlink" title="RELASE_TOKEN"></a>RELASE_TOKEN</h2><p>这个环境变量需要在 <a href="https://github.com/settings/tokens">Personal access tokens</a> 申请，需要注意的是，申请完成之后，不要着急关闭这个页面，因为一旦关闭就不能再次查看生成的 token 了，这个 token 需要申请 repo 和 workflow 的权限</p><p><img src="/posts/1610071792.jpeg"></p><p>生成 token 成功后，找到项目的 **Settings =&gt; Secrets **选项，新建名为 RELEASE_TOKEN 的 secrets 然后 value 值为刚才生成的 token。这个完成之后，就需要对设置生成 apk 需要的签名进行变量设置了。</p><h2 id="签名相关变量"><a href="#签名相关变量" class="headerlink" title="签名相关变量"></a>签名相关变量</h2><p>正常 app 签名步骤可以参考 <a href="https://flutterchina.club/android-release/#app%E7%AD%BE%E5%90%8D">app签名</a>，最终我们会创建一个 key.properties 的文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storePassword=&lt;password from previous step&gt;</span><br><span class="line">keyPassword=&lt;password from previous step&gt;</span><br><span class="line">keyAlias=key</span><br><span class="line">storeFile=&lt;location of the key store file, e.g. /Users/&lt;user name&gt;/key.jks&gt;</span><br></pre></td></tr></table></figure><p>然后在 android/app/build.grade 中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        keyAlias keystoreProperties[&#x27;keyAlias&#x27;]</span><br><span class="line">        keyPassword keystoreProperties[&#x27;keyPassword&#x27;]</span><br><span class="line">        storeFile keystoreProperties[&#x27;storeFile&#x27;] ? file(keystoreProperties[&#x27;storeFile&#x27;]) : null</span><br><span class="line">        storePassword keystoreProperties[&#x27;storePassword&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是将 key.properties 上传到仓库显然是不安全的。所以需要对代码进行修改，将对应的变量添加到 secrets  中，从 secrets  中获取变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">storeFile file(System.getenv(&quot;KEYSTORE&quot;) ?:&quot;keystore.jks&quot;)</span><br><span class="line">storePassword System.getenv(&quot;KEYSTORE_PASSWORD&quot;)</span><br><span class="line">keyAlias System.getenv(&quot;KEY_ALIAS&quot;)</span><br><span class="line">keyPassword System.getenv(&quot;KEY_PASSWORD&quot;)</span><br></pre></td></tr></table></figure><p>其中 **KEYSTORE_PASSWORD、KEY_ALIAS、KEY_PASSWORD **直接就可以添加，那么 **KEYSTORE **这个变量怎么处理呢？KEYSTORE 对应着 jks 文件位置。jks 文件显然也不可能上传到仓库，所以我们换种方法，在构建的时候生成 jks 文件。</p><h2 id="构建时生成-jks-文件"><a href="#构建时生成-jks-文件" class="headerlink" title="构建时生成 jks 文件"></a>构建时生成 jks 文件</h2><p>正常情况下打开生成的 jks 文件多半是乱码，所以我们可以通过 base64 对文件进行编码，然后在构建的时候，再解码重新生成文件。</p><h3 id="获取-base64-格式的-keystore"><a href="#获取-base64-格式的-keystore" class="headerlink" title="获取 base64 格式的 keystore"></a>获取 base64 格式的 keystore</h3><p>首先获取 base64 格式的 keystore </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl base64 -A -<span class="keyword">in</span> &lt;jks.文件位置&gt;</span><br></pre></td></tr></table></figure><p>然后将输出的结果复制下来</p><h3 id="保存-base64-格式的-keystore"><a href="#保存-base64-格式的-keystore" class="headerlink" title="保存 base64 格式的 keystore"></a>保存 base64 格式的 keystore</h3><p>将编码后的 keystore 内容，添加到 secrets ，变量名命名为 <strong>ENCODED_KEYSTORE，</strong>然后在构建过程中就可以将 keystore 文件还原了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ENCODED_KEYSTORE</span> | base64 -di &gt; android/app/keystore.jks</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间用 Flutter 做了一个开源的项目 &lt;a href=&quot;https://github.com/lt94/RSSAid&quot;&gt;RSSAi</summary>
      
    
    
    
    
    <category term="Github Action" scheme="https://leetaogoooo.github.io/tags/Github-Action/"/>
    
    <category term="Flutter" scheme="https://leetaogoooo.github.io/tags/Flutter/"/>
    
  </entry>
  
</feed>
